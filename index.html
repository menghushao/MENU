<!DOCTYPE html>

<html lang="zh-TW">
<head>
<meta charset="utf-8"/>
<title>è¨‚å–®ç³»çµ± V1.01.36</title>
<style>
    * { box-sizing: border-box; }
    body { font-family: sans-serif; padding: 20px; margin: 0; }

    select, input[type="text"], input[type="number"], input[type="datetime-local"] {
      font-size: 14px;
      padding: 6px 10px;
      margin: 4px 6px 10px 0;
    }

    .invalid { background-color: #ffe4e1 !important; }

    .btn {
      padding: 6px 12px;
      margin-right: 8px;
      cursor: pointer;
      border: 1px solid #bbb;
      background: #f2f2f2;
      font-size: 14px;
    }

    .btn.add { background: #e1f5fe; border-color: #81d4fa; }
    .btn.del { background: #ffcdd2; border-color: #e57373; }
    .btn.copy { background: #fff9c4; border-color: #fdd835; }

    .stickyBar {
      position: sticky;
      top: 0;
      background: white;
      padding: 10px 0;
      z-index: 100;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .groupCard {
      border: 2px dashed #aaa;
      padding: 12px;
      margin-bottom: 24px;
    }

    .groupHeader {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .orderContainer {
      display: flex;
      flex-wrap: nowrap;
      overflow-x: auto;
      gap: 16px;
      padding-bottom: 8px;
      margin-bottom: 10px;
    }

    .orderCard {
      flex: 0 0 auto;
      width: 250px;
      border: 1px solid #999;
      padding: 10px;
      background: #fcfcfc;
    }

    .orderTitle {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      margin-bottom: 6px;
    }

    .orderFields > div {
      margin-bottom: 6px;
    }

    .extraGrid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .summaryWrapper {
  font-size: 13px;
  white-space: pre-line;
  border-left: 4px solid #ccc;
  background: #f5f5f5;
  padding: 6px 10px;
  flex: 1;
  max-width: 100%;
  display: flex;
  flex-direction: column;
}

.summaryText {
  font-size: 13px;
  white-space: pre-line;
  padding-bottom: 4px;
}
      font-size: 13px;
      white-space: pre-line;
      border-left: 4px solid #ccc;
      background: #f5f5f5;
      padding: 6px 10px;
      flex: 1;
      max-width: 100%;
    }

    .rowLine {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    #logoutBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #eee;
      border: 1px solid #aaa;
      padding: 4px 8px;
      font-size: 13px;
      cursor: pointer;
      z-index: 9999;
    }
  
#logoutBtn { position: fixed; top: 10px; right: 10px; background: #eee; border: 1px solid #aaa; padding: 4px 8px; font-size: 13px; cursor: pointer; z-index: 9999; }

.orderLabel.defaultRed {
  color: #b22222;
}


    #dailyTotalsBar {
      background: white;
      padding: 6px 0; margin-top:4px;
      z-index: 101;
      border-bottom: 1px solid #ccc;
      display: flex; flex-basis: 100%; width:100%;
      gap: 12px;
      flex-wrap: wrap;
      font-size: 13px;
      align-items: center;
      margin-left: 10px;
    }

/* å€’æ•¸é¬§é˜æ¨£å¼ */
.countdown-wrapper {
  display: inline-flex;
  gap: 6px;
  align-items: center;
  margin-left: 8px;
  flex-wrap: nowrap;
  font-size: 250%;
}
.countdown-display {
  min-width: 60px;
  font-family: monospace;
  background: #222;
  color: #fff;
  padding: 4px 8px;
  border-radius: 4px;
  text-align: center;
}
.countdown-btn {
  padding: 4px 8px;
  font-size:  12px;
  cursor: pointer;
  border: 1px solid #888;
  border-radius: 3px;
  background: #f2f2f2;
}
.overtime-alert {
  animation: shake 0.6s ease-in-out infinite;
  filter: invert(100%);
  color: yellow !important;
}
@keyframes shake {
  0%,100% { transform: translateX(0); }
  20% { transform: translateX(-3px); }
  40% { transform: translateX(3px); }
  60% { transform: translateX(-2px); }
  80% { transform: translateX(2px); }
}
.task-countdown {
  margin-left: 6px;
  font-weight: bold;
  background: #222;
  color: #fff;
  padding: 2px 6px;
  border-radius: 4px;
  font-size:   150%;
}
/* fallback highlightï¼ˆå¦‚æœæ‰¾ä¸åˆ°å°æ‡‰ makeTask å…ƒç´ æ™‚ç”¨ï¼‰ */
.makeTask-fallback {
  background: #ffe8e8;
  border: 1px solid #d33;
  padding: 4px;
  margin-bottom: 2px;
}


#makeTasks { font-size: initial; }
#pickupTasks { font-size: 250%; }
</style>
</head>
<body>



<div id="topStickyWrapper" style="position:sticky; top:0; z-index:220; display:flex; flex-direction:column; background:white; border-bottom:1px solid #ccc; padding:8px;">
  <div id="taskListsWrapper" style="display:flex; gap:12px; margin-bottom:6px;">
    <div style="flex:1; height:20vh; border:1px solid #bbb; padding:6px; display:flex; flex-direction:column;">
      <div style="font-weight:bold; margin-bottom:4px;">å¾…è£½ä»»å‹™åˆ—è¡¨</div>
      <div id="makeTasks" style="display:flex; flex-direction:column; gap:4px; overflow:auto; flex:1;"></div>
    </div>
    <div style="flex:1; height:20vh; border:1px solid #bbb; padding:6px; display:flex; flex-direction:column;">
      <div style="font-weight:bold; margin-bottom:4px;">å¾…å–ä»»å‹™åˆ—è¡¨</div>
      <div id="pickupTasks" style="display:flex; flex-direction:column; gap:4px; overflow:auto; flex:1;"></div>
    </div>
  </div>
  <div class="stickyBar">
<h2>è¨‚å–®ç³»çµ± V1.01.36</h2>
<button class="btn add">â• æ–°å¢å®¢äºº</button><button class="btn" id="exportTxtBtn">ğŸ“¤ åŒ¯å‡ºTXT</button><button class="btn" id="importTxtBtn">ğŸ“¥ åŒ¯å…¥TXT</button>
<label>çƒ¤ç›¤è¨ˆæ™‚ï¼š
        <input style="width: 100px;" type="number" value="4"/>åˆ†
        <input style="width: 100px;" type="number" value="30"/>ç§’ï¼›
    </label>
<label>é¡†ç§’ï¼š
        <input style="width: 100px;" type="number" value="20"/>ï¼›
    </label>
<label>æ»¿
        <input style="width: 100px;" type="number" value="12"/> ä»½æŠ˜
        <input style="width: 100px;" type="number" value="1"/> ä»½ï¼›
    </label>
<label>æ»¿
        <input style="width: 100px;" type="number" value="60"/> å…ƒ
        <input style="width: 100px;" type="number" value="1"/> é»ï¼›
    </label>
<label>æ»¿
        <input style="width: 100px;" type="number" value="6"/> ä»½ä¹˜
        <input style="width: 100px;" type="number" value="2"/> å€ï¼›
    </label>
<label>é»å¡æŠ˜æŠµä¸Šé™ï¼š
        <input style="width: 100px;" type="number" value="35"/> å…ƒ
    </label>
    
</div>
  <div id="dailyTotalsBar" style="margin-bottom:5px;">
      <div id="dailyTotals" style="display:inline-block; margin-right:10px;"></div>
      <div id="paymentBreakdown" style="display:inline-block;"></div>
  </div>
</div>
</div>

<div>
<div id="groupsContainer">
<div class="groupCard">
<div class="groupHeader">
<div class="groupHeader">
<button class="btn del">âŒ</button>
<h3>ç¬¬ 1 çµ„å®¢äºº</h3>
</div>
<select>
<option>å·²å‡ºè²¨</option>
<option>å·²çµå¾…è£½</option>
<option selected="">æœªçµå¾…è£½</option>
<option>å·²çµå¾…å–</option>
<option>æœªçµå¾…å–</option>
<option>å–æ¶ˆè¨‚å–®</option>
</select>

<div class="summaryWrapper">
<div class="summaryText"></div>
<div class="summaryBoxText"></div>
</div>
</div>
<div class="rowLine"><button class="btn add">â• æ–°å¢è¨‚å–®</button>
<select>
<option value="">é¡§å®¢ä¾†æº</option>
<option>åˆ°åº—</option><option>é›»è©±</option><option>LINE</option>
<option>FB</option><option>IG</option><option>ç°¡è¨Š</option>
<option>ï¼µber Eats</option>
</select>
<select><option value="">æ”¯ä»˜æ–¹å¼</option></select>
<label>è¨»è¨˜ï¼š<input placeholder="è¨»è¨˜" type="text"/></label>
<input type="datetime-local"/><span class="pickupText" style="margin-left:6px; display:none;"></span>
<label>å¤–é€è³‡è¨Šï¼š<input placeholder="å¤–é€è³‡è¨Š" type="text"/></label><span class="deliveryText" style="margin-left:6px; display:none;"></span>
<label>é›†é»å¡å…Œæ›æ•¸é‡ï¼š<input type="number" value="0"/></label>
<label>é‡‘é¡èª¿æ•´ï¼š<input class="adjustInput" type="number"/></label>
<label><input type="checkbox"/> è‡ªå‚™å®¹å™¨</label>
</div>

<div class="orderContainer">
<!-- éœæ…‹ç”¢ç”Ÿ 6 çµ„è¨‚å–® -->
<div class="orderCard">
<div class="orderTitle">
<span></span>
<span class="costText"></span>
<button class="btn del">âŒ</button>
</div>
<div class="rowLine">
<select style="width: 100px;"><option value="">å“é …</option></select>
<input min="1" style="width: 100px;" type="number" value="1"/>
</div>
<div class="rowLine">
<select style="width: 100px;"><option value="">å•†å“A</option></select>
<select style="width: 100px;"><option value="">å•†å“B</option></select>
<select style="width: 62px;"><option value="">é™„</option></select>
<select style="width: 62px;"><option value="">é™„</option></select>
<select style="width: 62px;"><option value="">é™„</option></select>
<select style="width: 62px;"><option value="">é™„</option></select>
<select style="width: 62px;"><option value="">é™„</option></select>
<select style="width: 62px;"><option value="">é™„</option></select>
</div>
</div>
</div>
</div>
</div>
</div>
<button id="logoutBtn" style="position: fixed; top: 10px; right: 10px; background: #eee; border: 1px solid #aaa; padding: 4px 8px; font-size: 13px; cursor: pointer; z-index: 9999;">ğŸ”“ ç™»å‡ºé‡‘é‘°</button>
<script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
<script>
(() => {
  const FILE_URL = "https://raw.githubusercontent.com/menghushao/Order-management-product/main/gridData.json";
  const STORAGE_KEY = "gh_token";

  function logout() {
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
  }

  async function fetchGridData() {
    const res = await fetch(FILE_URL);
    return await res.json();
  }

  function decryptGrid(token, ciphertext, ivHex) {
    const key = CryptoJS.enc.Utf8.parse(token.slice(0, 32).padEnd(32, '0'));
    const iv = CryptoJS.enc.Hex.parse(ivHex);
    const encrypted = CryptoJS.enc.Base64.parse(ciphertext);
    const decrypted = CryptoJS.AES.decrypt({ ciphertext: encrypted }, key, {
      iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7
    });
    const json = decrypted.toString(CryptoJS.enc.Utf8);
    return JSON.parse(json);
  }

  async function ensureToken() {
    const cached = JSON.parse(localStorage.getItem(STORAGE_KEY) || "null");
    const now = Date.now();
    if (cached && now < cached.expires) return cached.token;

    let token;
    while (!token) {
      token = prompt("è«‹è¼¸å…¥ GitHub Tokenï¼š");
      if (!token) alert("å¿…é ˆè¼¸å…¥ token æ‰èƒ½ä½¿ç”¨ç³»çµ±ï¼");
    }

    const expires = now + 7 * 24 * 60 * 60 * 1000;
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ token, expires }));
    return token;
  }

  async function init() {
    const token = await ensureToken();
    let rawData;

    try {
      rawData = await fetchGridData();
    } catch (fetchErr) {
      console.warn("âš ï¸ è­¦å‘Šï¼šfetch ä¼¼ä¹å¤±æ•—ï¼Œä½†å¯èƒ½æˆåŠŸï¼ˆlocal file CORS èª¤å ±ï¼‰", fetchErr);
    }

    if (!rawData || !rawData.ciphertext || !rawData.iv) {
      alert("âš ï¸ ç„¡æ³•å–å¾—æ­£ç¢ºè³‡æ–™æ ¼å¼ï¼Œè«‹ç¢ºèª gridData.json æ˜¯å¦åŒ…å« ciphertext èˆ‡ iv");
      logout();
      return;
    }

    try {
      const decrypted = decryptGrid(token, rawData.ciphertext, rawData.iv);
      window.gridData = decrypted;
      // âœ… ç”¢ç”Ÿæ”¯ä»˜æ–¹å¼é¸å–®
      const paymentOptions = [
        ...new Set(decrypted[6].slice(15, 30).filter(Boolean)) // P~AD = index 15~29
      ];
      window.populatePaymentOptions = function(container = document) {
        container.querySelectorAll('select').forEach(sel => {
          if (sel.options[0]?.textContent === 'æ”¯ä»˜æ–¹å¼') {
            sel.innerHTML = '<option value="">æ”¯ä»˜æ–¹å¼</option>' +
              paymentOptions.map(opt => `<option>${opt}</option>`).join('');
          }
        });
      };
      window.populatePaymentOptions();

      document.querySelectorAll('select').forEach(sel => {
        if (sel.options[0]?.textContent === 'æ”¯ä»˜æ–¹å¼') {
          sel.innerHTML = '<option value="">æ”¯ä»˜æ–¹å¼</option>' +
            paymentOptions.map(opt => `<option>${opt}</option>`).join('');
        }
      });

  initGridDataCache();

      window.updateAccessoryOptions = function(card) {
        const decrypted = window.gridData;
        const selects = card.querySelectorAll('select');
        const productA = selects[1]?.value;
        const productB = selects[2]?.value;
        const finalProduct = productB || productA;
        if (!finalProduct) return;

        const matchedRow = decrypted.slice(10, 105).find(row => row[1] === finalProduct);
        if (!matchedRow) return;

        const options = matchedRow.slice(5, 15).filter(Boolean);
        const uniqueOptions = [...new Set(options)];

        selects.forEach(s => {
          if (s.options[0] && s.options[0].textContent === 'é™„') {
            s.innerHTML = '<option value="">é™„</option>' +
              uniqueOptions.map(x => `<option>${x}</option>`).join('');
          }
        });
      }

      document.querySelectorAll('.orderCard').forEach(card => {
        const selects = card.querySelectorAll('select');
        selects.forEach(s => {
          if (s.options[0] && (s.options[0].textContent === 'å•†å“A' || s.options[0].textContent === 'å•†å“B')) {
            s.addEventListener('change', () => updateAccessoryOptions(card));
          }
        });
      });

      console.log("âœ… è§£å¯†æˆåŠŸ", decrypted);

/*
  ğŸ” decrypted ç‚ºä¸€å€‹äºŒç¶­é™£åˆ—ï¼ˆArray of Arraysï¼‰ï¼Œå°æ‡‰åŸå§‹ Excel è³‡æ–™ç¯„åœï¼š
     - æ©«å‘æ¬„ä½ï¼šA ~ AXï¼ˆå…± 50 æ¬„ï¼‰
     - ç¸±å‘åˆ—æ•¸ï¼š1 ~ 106ï¼ˆå…± 106 åˆ—ï¼‰
  ä¾‹ï¼šdecrypted[0][0] å°æ‡‰ A1ï¼Œdecrypted[10][1] å°æ‡‰ B11
*/

      window.bindItemSelectLogic = function(container = document) {
        const decrypted = window.gridData;
        container.querySelectorAll('select').forEach(sel => {
          if (sel.options[0] && sel.options[0].textContent === 'å“é …') {
            sel.innerHTML = '<option value="">å“é …</option>' +
              [...new Set(decrypted.slice(10, 105).map(row => row[0]).filter(Boolean))]
              .map(x => `<option>${x}</option>`).join('');

            sel.addEventListener('change', e => {
              const selected = e.target.value;
              const card = e.target.closest('.orderCard');
              if (!selected || !card) return;

              const matched = decrypted.slice(10, 105)
                .filter(row => row[0] === selected)
                .map(row => row[1])
                .filter(Boolean);

              const unique = [...new Set(matched)];

              card.querySelectorAll('select').forEach(s => {
                if (
                  s.options[0] &&
                  (s.options[0].textContent === 'å•†å“A' || s.options[0].textContent === 'å•†å“B')
                ) {
                  s.innerHTML = '<option value="">' + s.options[0].textContent + '</option>' +
                    unique.map(x => `<option>${x}</option>`).join('');
                }
              });
            });
          }
        
          if (sel.options[0] && (sel.options[0].textContent === 'å•†å“A' || sel.options[0].textContent === 'å•†å“B')) {
            sel.addEventListener('change', e => {
              const card = e.target.closest('.orderCard');
              if (card) {
  window.updateAccessoryOptions(card);
  



function getItemPortionSummary(groupCard) {
  if (!window.gridData) return '';
  const rows = window.gridData.slice(10, 105);
  const ahOrder = rows.map(r => r[33]).filter(Boolean);
  const itemOrderMap = new Map(ahOrder.map((name, idx) => [name, idx]));

  const portionMap = new Map();
  const cards = [...groupCard.querySelectorAll('.orderCard')];

  for (const card of cards) {
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || '1');
    const a = selects[1]?.value;
    const b = selects[2]?.value;

    if (!a && !b) continue;

    const record = (val, q) => {
      const row = rows.find(r => r[1] === val); // Bæ¬„æ¯”å°
      if (!row) return;
      const item = row[0]; // Aæ¬„å“é …
      const perPortion = parseFloat(row[30]); // AEæ¬„
      if (!item || !perPortion || isNaN(perPortion)) return;
      if (!portionMap.has(item)) portionMap.set(item, { total: 0, perPortion });
      portionMap.get(item).total += q;
    };

    if (a && !b) record(a, qty);
    else if (!a && b) record(b, qty * 2);
    else {
      record(a, qty);
      record(b, qty);
    }
  }

  const result = [...portionMap.entries()]
    .sort((a, b) => (itemOrderMap.get(a[0]) ?? Infinity) - (itemOrderMap.get(b[0]) ?? Infinity))
    .map(([item, { total, perPortion }]) => {
      const intPart = Math.floor(total / perPortion);
      const remainder = total % perPortion;
      return `${item}${intPart}ä»½${remainder ? '(ä¸è¶³ä»½)' : ''}`;
    });

  return result.join('ï¼›');
}



// ğŸ”„ æ›´æ–° bindSummaryUpdater ä»¥åŒæ™‚è™•ç† summaryText èˆ‡ summaryBoxText








let rows = [], rowsMap = new Map(), ahOrder = [];

function initGridDataCache() {
  if (!window.gridData) return;
  rows = window.gridData.slice(10, 105);
  ahOrder = rows.map(r => r[33]);
  rowsMap = new Map(rows.map(r => [r[1], { short: r[2], type: r[0] }]));
}


function summarizeChunk(cards) {
  const map = new Map();
  for (const card of cards) {
    const s = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || 1);
    const a = s[1]?.value, b = s[2]?.value;
    const acc = [];
    for (let i = 3; i < 9; i++) {
      const v = s[i]?.value;
      if (v) acc.push(v);
    }

    const ra = rowsMap.get(a), rb = rowsMap.get(b);
    const sa = ra?.short || '', sb = rb?.short || '';
    const type = ra?.type || rb?.type || '';

    if (!sa && !sb) continue;
    const name = sa && sb ? [sa, sb].sort().join('+') : sa || `${sb}+${sb}`;
    const full = acc.length ? `${name}(${acc.join('+')})` : name;

    if (!map.has(full)) map.set(full, { count: 0, type, idx: map.size });
    map.get(full).count += qty;
  }

  return [...map.entries()]
    .sort((a, b) => ahOrder.indexOf(a[1].type) - ahOrder.indexOf(b[1].type) || a[1].idx - b[1].idx)
    .map(([k, v]) => `${k}X${v.count}`);
}

function getBoxSummaryText(groupCard) {
  if (!window.gridData) return '';
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const chunks = [];
  let chunk = [], splitCount = 0;

  for (const card of orderCards) {
    const hasValue = [...card.querySelectorAll('select')].some(s => s.value);
    if (hasValue) {
      chunk.push(card);
    } else {
      if (chunk.length) chunks.push(chunk);
      chunk = [];
      splitCount++;
    }
  }
  if (chunk.length) chunks.push(chunk);
  if (chunks.length <= 1 || splitCount === 0) return '';

  return chunks.map(cards => 'ã€' + summarizeChunk(cards).join('ï¼›') + 'ã€‘').join('');
}

function getSummaryText(groupCard) {
  if (!window.gridData) return '';
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  return summarizeChunk(orderCards).join('ï¼›');
}



window.checkOrderColor(card);
}
            });
          }});
      };

      // é é¢ä¸€é–‹å§‹ç¶å®šä¸€æ¬¡
      window.bindItemSelectLogic();

      // ç¶å®šå“é …é¸å–®çš„ onchange äº‹ä»¶ï¼Œæ›´æ–°å•†å“A/B
      document.querySelectorAll('select').forEach(sel => {
        if (sel.options[0] && sel.options[0].textContent === 'å“é …') {
          sel.addEventListener('change', e => {
            const selected = e.target.value;
            const card = e.target.closest('.orderCard');
            if (!selected || !card) return;

            const matched = decrypted.slice(10, 105)
              .filter(row => row[0] === selected)
              .map(row => row[1])
              .filter(Boolean);

            const unique = [...new Set(matched)];

            card.querySelectorAll('select').forEach(s => {
              if (
                s.options[0] &&
                (s.options[0].textContent === 'å•†å“A' || s.options[0].textContent === 'å•†å“B')
              ) {
                s.innerHTML = '<option value="">'+ s.options[0].textContent + '</option>' +
                  unique.map(x => `<option>${x}</option>`).join('');
              }
            });
          });
        }
      });

      const allItems = decrypted.slice(10, 105).map(row => row[0]).filter(Boolean);
      const uniqueItems = [...new Set(allItems)];

      document.querySelectorAll('select').forEach(sel => {
        if (sel.options[0] && sel.options[0].textContent === 'å“é …') {
          sel.innerHTML = '<option value="">å“é …</option>' +
            uniqueItems.map(x => `<option>${x}</option>`).join('');
        }
      });

    } catch (err) {
      alert("ç™»å…¥å¤±æ•—æˆ–è§£å¯†éŒ¯èª¤ï¼Œè«‹é‡æ–°ç™»å…¥ã€‚\n\néŒ¯èª¤è¨Šæ¯ï¼š" + err.message);
      logout();
    }
  }

  
window.findGroupContainer = function() {
  const existing = document.querySelector(".groupCard");
  if (existing && existing.parentElement) return existing.parentElement;
  const sticky = document.querySelector('.stickyBar');
  if (sticky) {
    let next = sticky.nextElementSibling;
    while (next) {
      if (next.tagName && next.tagName.toLowerCase() === 'div') return next;
      next = next.nextElementSibling;
    }
  }
  return document.body;
};
document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("logoutBtn");
    if (btn) {
      btn.addEventListener("click", () => {
        console.log("ğŸ”“ ä½¿ç”¨è€…é»æ“Šç™»å‡ºé‡‘é‘°");
        logout();
      });
    }
    init();
  });
})();
</script>
<script>
document.addEventListener("DOMContentLoaded", () => {
  const original = document.querySelector(".groupCard");
  const groupTemplate = original.cloneNode(true);
  window.groupTemplate = groupTemplate;
const addBtn = document.querySelector(".stickyBar .btn.add");

  if (addBtn && !addBtn.classList.contains("bound")) {
    addBtn.classList.add("bound");

    addBtn.addEventListener("click", () => {
      let container = original?.parentElement; if (!container) container = window.findGroupContainer();
      const clone = groupTemplate.cloneNode(true);

      const count = container.querySelectorAll(".groupCard").length + 1;
      const h3 = clone.querySelector("h3");
      if (h3) h3.textContent = `ç¬¬ ${count} çµ„å®¢äºº`;

      container.appendChild(clone);

      initGroup(clone);
      window.bindItemSelectLogic(clone);
      bindSummaryUpdater(clone);
      bindCopyButton(clone);
      if (window.populatePaymentOptions) window.populatePaymentOptions(clone);
    });
  }

  // åˆå§‹åŒ–æ¯çµ„ groupCard çš„è¡Œç‚º
  
// å€’æ•¸é¬§é˜åŠŸèƒ½ - helper functions
function formatTime(sec) {
  const sign = sec < 0 ? '-' : '';
  const abs = Math.abs(Math.floor(sec));
  const m = Math.floor(abs / 60).toString().padStart(2, '0');
  const s = (abs % 60).toString().padStart(2, '0');
  return sign + m + ':' + s;
}

function ensureCountdownControl(group) {
  if (group.__hasCountdown) return;
  group.__hasCountdown = true;

  const containerLabel = [...group.querySelectorAll('label')].find(l => l.textContent.includes('è‡ªå‚™å®¹å™¨'));
  const statusSelect = group.querySelector('.groupHeader > select');
  if (statusSelect) {
    statusSelect.addEventListener('change', () => {
      const val = statusSelect.value;
      if (targetTime && val !== 'æœªçµå¾…è£½' && val !== 'å·²çµå¾…è£½') {
        resetCountdown();
      }
    });
  }

  if (!containerLabel) return;

  const wrapper = document.createElement('div');
  wrapper.className = 'countdown-wrapper';
  wrapper.innerHTML = `
    <div class="countdown-display">00:00</div>
    <input type="number" class="countdown-duration" title="å€’æ•¸ç§’æ•¸" style="width:70px;" min="1" value="270" placeholder="ç§’"/>
    <input type="text" class="countdown-audio" title="éŸ³æ•ˆè·¯å¾‘" style="width:260px;" value="C:\\Users\\add00\\OneDrive\\æ¡Œé¢\\èŒè™ç‡’\\ä¸­è¯ä¸€ç•ªï¼ost+4.ä¸‡é‡Œã®é•·åŸ.mp3" placeholder="éŸ³æ•ˆ URL"/>
    <input type="number" class="countdown-audio-duration" title="æ’­æ”¾ç§’æ•¸" style="width:70px;" min="1" value="15" placeholder="æ’­æ”¾ç§’"/>
    <button class="countdown-start countdown-btn">å•Ÿå‹•</button>
    <button class="countdown-stop countdown-btn" disabled>åœæ­¢</button>
    <button class="countdown-reset countdown-btn">é‡ç½®</button>
  `;
  containerLabel.parentElement.appendChild(wrapper);

  const display = wrapper.querySelector('.countdown-display');
  const durationInput = wrapper.querySelector('.countdown-duration');
  const audioInput = wrapper.querySelector('.countdown-audio');
  const audioDurInput = wrapper.querySelector('.countdown-audio-duration');
  const startBtn = wrapper.querySelector('.countdown-start');
  const stopBtn = wrapper.querySelector('.countdown-stop');
  const resetBtn = wrapper.querySelector('.countdown-reset');

  let targetTime = null;
  let remaining = parseInt(durationInput.value,10) || 270;
  let timerId = null;
  let alerted = false;
  let audio = new Audio();
  let audioTimeout = null;

  function updateDisplay() {
    if (!targetTime) {
      display.textContent = formatTime(remaining);
      return;
    }
    const now = Date.now();
    const diff = Math.round((targetTime - now)/1000);
    display.textContent = formatTime(diff);
    if (diff < 0 && !alerted) {
      alerted = true;
      triggerAlert();
    }
  }

  function tick() { updateDisplay(); }

  
  function startCountdown() {

    const statusSelect = group.querySelector('.groupHeader > select');
    const status = statusSelect?.value;
    if (status !== 'æœªçµå¾…è£½' && status !== 'å·²çµå¾…è£½') {
      alert('åªæœ‰ã€Œæœªçµå¾…è£½ã€æˆ–ã€Œå·²çµå¾…è£½ã€ç‹€æ…‹æ‰èƒ½å•Ÿå‹•å€’æ•¸');
      return;
    }
    // ä½¿ç”¨ç¾å­˜ remaining ç•¶ä½œè¦ç¹¼çºŒçš„æ™‚é–“ï¼ˆåœæ­¢ä¹‹å¾Œ resumeï¼‰ï¼Œreset æœƒé‡æ–°è¨­å®š remaining
    if (remaining == null || isNaN(remaining)) {
      const dur = parseInt(durationInput.value, 10);
      remaining = isNaN(dur) || dur <= 0 ? 270 : dur;
    }
    const now = Date.now();
    targetTime = now + remaining * 1000;
    // å¦‚æœå·²ç¶“é¡¯ç¤ºé alertï¼ˆå·²è¶…æ™‚ï¼‰å°±ä¿ç•™ alerted ç‹€æ…‹ï¼Œå¦å‰‡ä¿æŒåŸæ¨£
    startBtn.disabled = true;
    stopBtn.disabled = false;
    if (timerId) clearInterval(timerId);
    timerId = setInterval(tick, 250);
    updateDisplay();
  }


  function stopCountdown() {
    if (timerId) clearInterval(timerId);
    if (targetTime) {
      const now = Date.now();
      remaining = Math.round((targetTime - now)/1000);
    }
    targetTime = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    updateDisplay();
  }

  function resetCountdown() {
    if (timerId) clearInterval(timerId);
    const dur = parseInt(durationInput.value,10);
    remaining = isNaN(dur) || dur <= 0 ? 270 : dur;
    targetTime = null;
    alerted = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    display.textContent = formatTime(remaining);
    clearAlertOnThisTask();
    display.style.fontWeight='normal';
  }

  function triggerAlert() {
    display.style.fontWeight='bold';
    highlightMakeTask();
    audio.src = audioInput.value;
    audio.play().catch(()=>{});
    const playDur = parseInt(audioDurInput.value,10);
    if (!isNaN(playDur) && playDur>0) {
      if (audioTimeout) clearTimeout(audioTimeout);
      audioTimeout = setTimeout(()=>{ audio.pause(); }, playDur*1000);
    }
  }

  function highlightMakeTask() {
    const makeContainer = document.getElementById('makeTasks');
    if (!makeContainer) return;
    const title = group.querySelector('h3')?.textContent || '';
    let itemDiv = Array.from(makeContainer.children).find(c => (c.textContent || '').includes(title));
    if (itemDiv) {
      itemDiv.classList.add('overtime-alert');
    } else {
      const placeholder = document.createElement('div');
      placeholder.textContent = `âš ï¸ ${title} å€’æ•¸è¶…æ™‚ï¼ˆå·²è¶…æ™‚ï¼‰`;
      placeholder.className = 'overtime-alert makeTask-fallback';
      makeContainer.prepend(placeholder);
    }
  }
  function clearAlertOnThisTask() {
    const makeContainer = document.getElementById('makeTasks');
    if (!makeContainer) return;
    const title = group.querySelector('h3')?.textContent || '';
    let itemDiv = Array.from(makeContainer.children).find(c => (c.textContent || '').includes(title));
    if (itemDiv) {
      itemDiv.classList.remove('overtime-alert');
    }
    // ç§»é™¤ fallback placeholderï¼ˆè‹¥æœ‰çš„è©±ï¼‰
    Array.from(makeContainer.querySelectorAll('.makeTask-fallback')).forEach(el => {
      if (el.textContent.includes(title)) {
        el.remove();
      }
    });
  }


  function clearAlertOnTask() {
    const makeContainer = document.getElementById('makeTasks');
    if (!makeContainer) return;
    Array.from(makeContainer.children).forEach(c => c.classList.remove('overtime-alert'));
  }

  startBtn.addEventListener('click', startCountdown);
  stopBtn.addEventListener('click', stopCountdown);
  resetBtn.addEventListener('click', resetCountdown);

  display.textContent = formatTime(remaining);
}



// åŒæ­¥å€’æ•¸æ™‚é–“åˆ°å¾…è£½ä»»å‹™åˆ—è¡¨ï¼ˆå¾…è£½ä»»å‹™åˆ—è¡¨å³å´ badgeï¼‰
function syncCountdownsToMakeTasks() {
  const makeContainer = document.getElementById('makeTasks');
  if (!makeContainer) return;
  document.querySelectorAll('.groupCard').forEach(group => {
    if (!group.__hasCountdown) return;
    const display = group.querySelector('.countdown-display');
    if (!display) return;
    const countdownText = display.textContent;
    const groupName = group.querySelector('h3')?.textContent?.trim() || '';
    if (!groupName) return;
    const entry = Array.from(makeContainer.children).find(c => (c.textContent || '').includes(groupName));
    if (!entry) return;
    let badge = entry.querySelector('.task-countdown');
    if (!badge) {
      badge = document.createElement('span');
      badge.className = 'task-countdown';
      badge.style.marginLeft = '6px';
      badge.style.fontWeight = 'bold';
      badge.style.background = '#222';
      badge.style.color = '#fff';
      badge.style.padding = '2px 6px';
      badge.style.borderRadius = '4px';
      
      entry.prepend(badge);
    }
    badge.textContent = countdownText;
    if (countdownText.startsWith('-')) {
      badge.style.filter = 'invert(100%)';
    } else {
      badge.style.filter = '';
    }
  });
}
setInterval(syncCountdownsToMakeTasks, 500);

function initGroup(group) {
    // å®¢æˆ¶ä¾†æºæ™‚é–“é¡¯ç¤ºï¼ˆåœ¨è¨‚å–®è³‡è¨Šå…§ï¼Œé¸æ“‡å¾Œé¡¯ç¤º hh:mm:ssï¼‰
    const sourceSelect = [...group.querySelectorAll(".rowLine select")].find(sel => [...sel.options].some(o => o.textContent === "é¡§å®¢ä¾†æº"));
    if (sourceSelect) {
      sourceSelect.addEventListener('change', () => {
        if (!sourceSelect.value) {
          delete group.dataset.customerSourceTime;
          if (typeof updateTaskLists === 'function') updateTaskLists();
          return;
        }
        const now = new Date();
        const hh = now.getHours().toString().padStart(2, '0');
        const mm = now.getMinutes().toString().padStart(2, '0');
        const ss = now.getSeconds().toString().padStart(2, '0');
        group.dataset.customerSourceTime = `${hh}:${mm}:${ss}`;
        if (typeof updateTaskLists === 'function') updateTaskLists();
      });
    }
// è¬å¹´æ›†æ™‚é–“é¡¯ç¤ºï¼ˆå–é¤ / é€é”ï¼‰
    function updateCalendarDisplay() {
      const datetimeInput = group.querySelector('input[type="datetime-local"]');
      const deliveryInput = [...group.querySelectorAll('label')].find(l => l.textContent.includes('å¤–é€è³‡è¨Š'))?.querySelector('input');
      const pickupSpan = group.querySelector('.pickupText');
      const deliverySpan = group.querySelector('.deliveryText');
      const dtVal = datetimeInput?.value;
      const deliveryVal = deliveryInput?.value;
      if (!dtVal) {
        if (pickupSpan) pickupSpan.style.display = 'none';
        if (deliverySpan) deliverySpan.style.display = 'none';
        return;
      }
      const dt = new Date(dtVal);
      const pad = n => n.toString().padStart(2, '0');
      const dateStr = `${dt.getFullYear()}/${pad(dt.getMonth()+1)}/${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}`;
      if (deliveryVal) {
        if (deliverySpan) {
          deliverySpan.textContent = `${dateStr}é€é”`;
          deliverySpan.style.display = '';
        }
        if (pickupSpan) pickupSpan.style.display = 'none';
      } else {
        if (pickupSpan) {
          pickupSpan.textContent = `${dateStr}å–é¤`;
          pickupSpan.style.display = '';
        }
        if (deliverySpan) deliverySpan.style.display = 'none';
      }
    }
    const datetimeInput = group.querySelector('input[type="datetime-local"]');
    const deliveryInput = [...group.querySelectorAll('label')].find(l => l.textContent.includes('å¤–é€è³‡è¨Š'))?.querySelector('input');
    if (datetimeInput) {
      datetimeInput.addEventListener('change', updateCalendarDisplay);
      datetimeInput.addEventListener('input', updateCalendarDisplay);
    }
    if (deliveryInput) {
      deliveryInput.addEventListener('input', updateCalendarDisplay);
      deliveryInput.addEventListener('change', updateCalendarDisplay);
    }

    const orderContainer = group.querySelector(".orderContainer");
    const addOrderBtn = group.querySelector(".rowLine .btn.add");
    let orderCount = orderContainer.children.length;
    let swapTarget = null;

    function clearSwapHighlight() {
      orderContainer.querySelectorAll(".btn.swap").forEach(btn => {
        btn.style.background = "#eee";
      });
    }

    function bindCardEvents(card) {
      const delBtn = card.querySelector(".btn.del");
      if (delBtn) {
        
delBtn.addEventListener("click", () => {
  if (confirm("ç¢ºå®šè¦åˆªé™¤é€™çµ„è¨‚å–®å—ï¼Ÿ")) {
    const groupCard = card.closest('.groupCard');
    card.remove();
    if (groupCard) {
      if (window.bindSummaryUpdater) {
        window.bindSummaryUpdater(groupCard);
      }
      groupCard.querySelectorAll('.orderCard').forEach(window.checkOrderColor);
            if (typeof updateTaskLists === 'function') updateTaskLists();
    }
  }
});

      }

      const swapBtn = card.querySelector(".btn.swap");
      if (swapBtn) {
        swapBtn.addEventListener("click", () => {
          if (swapTarget === null) {
            swapTarget = card;
            clearSwapHighlight();
            swapBtn.style.background = "khaki";
          } else if (swapTarget === card) {
            swapTarget = null;
            clearSwapHighlight();
          } else {
          const selects1 = swapTarget.querySelectorAll('select');
          const selects2 = card.querySelectorAll('select');
          const inputs1 = swapTarget.querySelectorAll('input');
          const inputs2 = card.querySelectorAll('input');

          const values1 = [...selects1].map(s => s.value);
          const values2 = [...selects2].map(s => s.value);
          const inputsVal1 = [...inputs1].map(s => s.value);
          const inputsVal2 = [...inputs2].map(s => s.value);

          [...selects1].forEach((s, i) => {
            s.value = values2[i] || "";
            s.dispatchEvent(new Event('change', { bubbles: true }));
          });
          [...selects2].forEach((s, i) => {
            s.value = values1[i] || "";
            s.dispatchEvent(new Event('change', { bubbles: true }));
          });

          [...inputs1].forEach((s, i) => {
            s.value = inputsVal2[i] || "";
            s.dispatchEvent(new Event('input', { bubbles: true }));
          });
          [...inputs2].forEach((s, i) => {
            s.value = inputsVal1[i] || "";
            s.dispatchEvent(new Event('input', { bubbles: true }));
          });

          // â¬‡ï¸ æ–°å¢äº¤æ›è¨‚å–®æ¨™ç±¤ï¼ˆorderLabelï¼‰æ–‡å­—
          const label1 = swapTarget.querySelector(".orderLabel");
          const label2 = card.querySelector(".orderLabel");
          if (label1 && label2) {
            const tmp = label1.textContent;
            label1.textContent = label2.textContent;
            label2.textContent = tmp;
          }

          swapTarget = null;

          swapTarget = null;
          clearSwapHighlight();
}
        });
      }
    }

    function createOrderCard(index) {
      const card = document.createElement("div");
      card.className = "orderCard";
      card.dataset.index = index;
      card.innerHTML = `
        <div class="orderTitle">
          <button class="btn swap" style="background:#eee;">â‡„</button>
          <span class="orderLabel defaultRed">ç¬¬ ${index + 1} çµ„è¨‚å–®</span>
          <span class="costText"></span>
          <button class="btn del">âŒ</button>
        </div>
        <div class="rowLine">
          <select style="width: 100px;"><option value="">å“é …</option></select>
          <input type="number" min="1" value="1" style="width: 100px;">
        </div>
        <div class="rowLine">
          <select style="width: 100px;"><option value="">å•†å“A</option></select>
          <select style="width: 100px;"><option value="">å•†å“B</option></select>
          <select style="width: 62px;"><option value="">é™„</option></select>
          <select style="width: 62px;"><option value="">é™„</option></select>
          <select style="width: 62px;"><option value="">é™„</option></select>
          <select style="width: 62px;"><option value="">é™„</option></select>
          <select style="width: 62px;"><option value="">é™„</option></select>
          <select style="width: 62px;"><option value="">é™„</option></select>
        </div>
      `;
      bindCardEvents(card);
      checkOrderColor(card);
      window.bindItemSelectLogic(card); return card;
    }

    if (addOrderBtn) {
      addOrderBtn.addEventListener("click", () => {
        for (let i = 0; i < 5; i++) {
          const card = createOrderCard(orderCount);
          orderContainer.appendChild(card);
          orderCount++;
          bindSummaryUpdater(group);
        }
        orderContainer.scrollLeft = orderContainer.scrollWidth;
      });
    }

    // åˆå§‹åŒ–ç¾æœ‰è¨‚å–®ï¼ˆé¿å…ç¬¬ä¸€çµ„ä¸èƒ½äº¤æ›ï¼‰
    [...orderContainer.children].forEach((card, idx) => {
      if (!card.querySelector(".btn.swap")) {
        const titleDiv = card.querySelector(".orderTitle");
        const swapBtn = document.createElement("button");
        swapBtn.className = "btn swap";
        swapBtn.textContent = "â‡„";
        swapBtn.style.background = "#eee";
        titleDiv.insertBefore(swapBtn, titleDiv.firstChild);
      }

      let label = card.querySelector(".orderLabel");
      if (!label) {
        label = document.createElement("span");
        label.className = "orderLabel";
        card.querySelector(".orderTitle").insertBefore(label, card.querySelector(".costText"));
      }
      label.textContent = `ç¬¬ ${idx + 1} çµ„è¨‚å–®`;

      bindCardEvents(card);
      checkOrderColor(card);
    });
  ensureCountdownControl(group);
  }

  // åˆå§‹åŒ–é é¢ç¬¬ä¸€çµ„
  document.querySelectorAll(".groupCard").forEach(group => {
  if (window.populatePaymentOptions) window.populatePaymentOptions(group);
  initGroup(group);
  bindSummaryUpdater(group);
});
});

function getSummaryText(groupCard) {
  const decrypted = window.gridData;
  if (!decrypted) return '';

  const rows = decrypted.slice(10, 105);
  const ahOrder = rows.map(row => row[33]);
  const orderContainer = groupCard.querySelector('.orderContainer');
  const allOrders = [...orderContainer.querySelectorAll('.orderCard')];

  const summaryMap = new Map();

  for (const card of allOrders) {
    const selects = card.querySelectorAll('select');
    const qtyInput = card.querySelector('input[type="number"]');
    const qty = parseInt(qtyInput?.value || '1');

    const itemA = selects[1]?.value;
    const itemB = selects[2]?.value;
    const accessories = [...selects].slice(3, 9).map(s => s.value).filter(Boolean);

    let shortA = '', shortB = '', itemType = '';
    if (itemA) {
      const row = rows.find(r => r[1] === itemA);
      if (row) { shortA = row[2]; itemType = row[0]; }
    }
    if (itemB) {
      const row = rows.find(r => r[1] === itemB);
      if (row) { shortB = row[2]; if (!itemType) itemType = row[0]; }
    }

    if (!shortA && !shortB) continue;

    let baseName = '';
if (shortA && shortB) {
  const sortedNames = [shortA, shortB].sort();
  baseName = `${sortedNames[0]}+${sortedNames[1]}`;
} else if (shortB) {
  baseName = `${shortB}+${shortB}`;
} else if (shortA) {
  baseName = shortA;
}
const accessoriesStr = accessories.length ? `(${accessories.join('+')})` : '';
const fullName = `${baseName}${accessoriesStr}`;

    if (!summaryMap.has(fullName)) {
      summaryMap.set(fullName, { count: 0, type: itemType, index: summaryMap.size });
    }
    summaryMap.get(fullName).count += qty;
  }

  const sorted = [...summaryMap.entries()].sort((a, b) => {
    const typeA = a[1].type;
    const typeB = b[1].type;
    const idxA = ahOrder.indexOf(typeA);
    const idxB = ahOrder.indexOf(typeB);
    if (idxA !== idxB) return idxA - idxB;
    return a[1].index - b[1].index;
  });

  return sorted.map(([name, val]) => `${name}X${val.count}`).join('ï¼›');
}




function bindCopyButton(groupCard) {
  const btn = groupCard.querySelector('.groupHeader .btn.del');
  if (!btn) return;
  if (btn.dataset.copyBound) return;
  btn.dataset.copyBound = '1';
  btn.textContent = 'ğŸ“‹';
  btn.classList.remove('del');
  btn.classList.add('copy');
  btn.title = 'è¤‡è£½è¨‚å–®è³‡è¨Š';
  btn.addEventListener('click', () => {
    const groupName = groupCard.querySelector('h3')?.textContent || '';
    const status = groupCard.querySelector('.groupHeader > select')?.value || '';
    const summaryText = groupCard.querySelector('.summaryText')?.textContent || '';
    const boxSummaryText = groupCard.querySelector('.summaryBoxText')?.textContent || '';
    const fullText = `${groupName}\nç‹€æ…‹: ${status}\n${summaryText}\n${boxSummaryText}`;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(fullText).then(() => {
        alert('è¨‚å–®è³‡è¨Šå·²è¤‡è£½');
      }, () => {
        alert('è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½:\n' + fullText);
      });
    } else {
      const ta = document.createElement('textarea');
      ta.value = fullText;
      document.body.appendChild(ta);
      ta.select();
      try {
        document.execCommand('copy');
        alert('è¨‚å–®è³‡è¨Šå·²è¤‡è£½');
      } catch (e) {
        if (e.name === 'AbortError') {
          console.log('ä½¿ç”¨è€…å·²å–æ¶ˆåŒ¯å‡º');
          return;
        }
        alert('è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½:\n' + fullText);
      }
      document.body.removeChild(ta);
    }
  });
}


function initAllSummaries() {
  document.querySelectorAll('.groupCard').forEach(g => { bindSummaryUpdater(g); bindCopyButton(g); });
}

document.addEventListener('DOMContentLoaded', () => {
  initAllSummaries();
});


function getBoxSummaryText(groupCard) {
  const decrypted = window.gridData;
  if (!decrypted) return '';

  const rows = decrypted.slice(10, 105);
  const ahOrder = rows.map(row => row[33]);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];

  const chunks = [];
  let currentChunk = [];

  for (const card of orderCards) {
    const selects = card.querySelectorAll('select');
    const hasContent = [...selects].some(s => s.value);
    if (hasContent) {
      currentChunk.push(card);
    } else {
      if (currentChunk.length) chunks.push(currentChunk);
      currentChunk = [];
    }
  }
  if (currentChunk.length) chunks.push(currentChunk);

  if (chunks.length <= 1) return '';
  const result = chunks.map(chunk => {
    const map = new Map();
    chunk.forEach(card => {
      const selects = card.querySelectorAll('select');
      const qtyInput = card.querySelector('input[type="number"]');
      const qty = parseInt(qtyInput?.value || '1');

      const itemA = selects[1]?.value;
      const itemB = selects[2]?.value;
      const accessories = [...selects].slice(3, 9).map(s => s.value).filter(Boolean);

      let shortA = '', shortB = '', itemType = '';
      if (itemA) {
        const row = rows.find(r => r[1] === itemA);
        if (row) { shortA = row[2]; itemType = row[0]; }
      }
      if (itemB) {
        const row = rows.find(r => r[1] === itemB);
        if (row) { shortB = row[2]; if (!itemType) itemType = row[0]; }
      }

      if (!shortA && !shortB) return;

      let baseName = '';
      if (shortA && shortB) {
        const sortedNames = [shortA, shortB].sort();
        baseName = `${sortedNames[0]}+${sortedNames[1]}`;
      } else if (shortB) {
        baseName = `${shortB}+${shortB}`;
      } else if (shortA) {
        baseName = shortA;
      }
      const accessoriesStr = accessories.length ? `(${accessories.join('+')})` : '';
      const fullName = `${baseName}${accessoriesStr}`;

      if (!map.has(fullName)) {
        map.set(fullName, { count: 0, type: itemType, index: map.size });
      }
      map.get(fullName).count += qty;
    });

    const sorted = [...map.entries()].sort((a, b) => {
      const idxA = ahOrder.indexOf(a[1].type);
      const idxB = ahOrder.indexOf(b[1].type);
      if (idxA !== idxB) return idxA - idxB;
      return a[1].index - b[1].index;
    });

    return `ã€${sorted.map(([name, val]) => `${name}X${val.count}`).join('ï¼›')}ã€‘`;
  });

  return result.join('');
}


function getItemPortionSummary(groupCard) {
  if (!window.gridData) return '';
  const rows = window.gridData.slice(10, 105);
  const ahOrder = rows.map(r => r[33]).filter(Boolean);
  const itemOrderMap = new Map(ahOrder.map((name, idx) => [name, idx]));

  const portionMap = new Map();
  const cards = [...groupCard.querySelectorAll('.orderCard')];

  for (const card of cards) {
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || '1');
    const a = selects[1]?.value;
    const b = selects[2]?.value;

    if (!a && !b) continue;

    const record = (val, q) => {
      const row = rows.find(r => r[1] === val); // Bæ¬„æ¯”å°
      if (!row) return;
      const item = row[0]; // Aæ¬„å“é …
      const perPortion = parseFloat(row[30]); // AEæ¬„
      if (!item || !perPortion || isNaN(perPortion)) return;
      if (!portionMap.has(item)) portionMap.set(item, { total: 0, perPortion });
      portionMap.get(item).total += q;
    };

    if (a && !b) record(a, qty);
    else if (!a && b) record(b, qty * 2);
    else {
      record(a, qty);
      record(b, qty);
    }
  }

  const result = [...portionMap.entries()]
    .sort((a, b) => (itemOrderMap.get(a[0]) ?? Infinity) - (itemOrderMap.get(b[0]) ?? Infinity))
    .map(([item, { total, perPortion }]) => {
      const intPart = Math.floor(total / perPortion);
      const remainder = total % perPortion;
      return `${item}${intPart}ä»½${remainder ? '(ä¸è¶³ä»½)' : ''}`;
    });

  return result.join('ï¼›');
}


// ğŸ”„ æ›´æ–° bindSummaryUpdater ä»¥åŒæ™‚è™•ç† summaryText èˆ‡ summaryBoxText




function getBoxSummaryText(groupCard) {
  const decrypted = window.gridData;
  if (!decrypted) return '';

  const rows = decrypted.slice(10, 105);
  const ahOrder = rows.map(r => r[33]);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];

  const chunks = [];
  let chunk = [], splitCount = 0;

  for (const card of orderCards) {
    const hasValue = [...card.querySelectorAll('select')].some(s => s.value);
    if (hasValue) {
      chunk.push(card);
    } else {
      if (chunk.length) chunks.push(chunk);
      chunk = [];
      splitCount++;
    }
  }
  if (chunk.length) chunks.push(chunk);
  if (chunks.length <= 1 || splitCount === 0) return '';

  return chunks.map(cards => {
    const map = new Map();
    cards.forEach(card => {
      const s = card.querySelectorAll('select');
      const qty = parseInt(card.querySelector('input[type="number"]')?.value || 1);
      const a = s[1]?.value, b = s[2]?.value;
      const acc = [...s].slice(3, 9).map(x => x.value).filter(Boolean);
      let sa = '', sb = '', type = '';

      for (const [val, set] of [[a, () => sa = rows.find(r => r[1] === a)?.[2]], [b, () => sb = rows.find(r => r[1] === b)?.[2]]]) {
        if (val) {
          const row = rows.find(r => r[1] === val);
          if (row) { if (!type) type = row[0]; if (set) set(); }
        }
      }

      if (!sa && !sb) return;
      const name = sa && sb ? [sa, sb].sort().join('+') : sa || `${sb}+${sb}`;
      const full = name + (acc.length ? `(${acc.join('+')})` : '');
      if (!map.has(full)) map.set(full, { count: 0, type, idx: map.size });
      map.get(full).count += qty;
    });

    return 'ã€' + [...map.entries()]
      .sort((a, b) => ahOrder.indexOf(a[1].type) - ahOrder.indexOf(b[1].type) || a[1].idx - b[1].idx)
      .map(([k, v]) => `${k}X${v.count}`).join('ï¼›') + 'ã€‘';
  }).join('');
}


let rows = [], rowsMap = new Map(), ahOrder = [];

function initGridDataCache() {
  if (!window.gridData) return;
  rows = window.gridData.slice(10, 105);
  ahOrder = rows.map(r => r[33]);
  rowsMap = new Map(rows.map(r => [r[1], { short: r[2], type: r[0] }]));
}


function summarizeChunk(cards) {
  const map = new Map();
  for (const card of cards) {
    const s = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || 1);
    const a = s[1]?.value, b = s[2]?.value;
    const acc = [];
    for (let i = 3; i < 9; i++) {
      const v = s[i]?.value;
      if (v) acc.push(v);
    }

    const ra = rowsMap.get(a), rb = rowsMap.get(b);
    const sa = ra?.short || '', sb = rb?.short || '';
    const type = ra?.type || rb?.type || '';

    if (!sa && !sb) continue;
    const name = sa && sb ? [sa, sb].sort().join('+') : sa || `${sb}+${sb}`;
    const full = acc.length ? `${name}(${acc.join('+')})` : name;

    if (!map.has(full)) map.set(full, { count: 0, type, idx: map.size });
    map.get(full).count += qty;
  }

  return [...map.entries()]
    .sort((a, b) => ahOrder.indexOf(a[1].type) - ahOrder.indexOf(b[1].type) || a[1].idx - b[1].idx)
    .map(([k, v]) => `${k}X${v.count}`);
}

function getBoxSummaryText(groupCard) {
  if (!window.gridData) return '';
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const chunks = [];
  let chunk = [], splitCount = 0;

  for (const card of orderCards) {
    const hasValue = [...card.querySelectorAll('select')].some(s => s.value);
    if (hasValue) {
      chunk.push(card);
    } else {
      if (chunk.length) chunks.push(chunk);
      chunk = [];
      splitCount++;
    }
  }
  if (chunk.length) chunks.push(chunk);
  if (chunks.length <= 1 || splitCount === 0) return '';

  return chunks.map(cards => 'ã€' + summarizeChunk(cards).join('ï¼›') + 'ã€‘').join('');
}

function getSummaryText(groupCard) {
  if (!window.gridData) return '';
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  return summarizeChunk(orderCards).join('ï¼›');
}



window.checkOrderColor = function(card) {
  const selects = card.querySelectorAll('select');
  const productA = selects[1]?.value;
  const productB = selects[2]?.value;
  const label = card.querySelector('.orderLabel');
  if (!label) return;
  if (productA || productB) {
    label.classList.remove('defaultRed');
  } else {
    label.classList.add('defaultRed');
  }
};

</script>

<script>
// âœ… åƒ…åµŒå…¥è¨‚å–®é‡‘é¡é‚è¼¯ï¼ˆæ­£ç¢ºçš„A/Bæ•¸é‡åŠ ä¹˜ï¼‰
function calculateTotalAmount(groupCard) {
  const grid = window.gridData;
  if (!grid) return 0;
  const rows = grid.slice(10, 105);
  const labelMap = grid[0];
  const comboQtyMap = grid[1];
  const specialPriceMap = grid[2];
  const payMethodMap = grid[3];
  const priceHeaders = grid[6].slice(15, 30);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';

  const totalItems = new Map();

  for (const card of orderCards) {
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || '1');
    const a = selects[1]?.value;
    const b = selects[2]?.value;

    const isValid = name => rows.some(r => r[1] === name);
    const validA = a && isValid(a);
    const validB = b && isValid(b);

    const add = (name, count) => {
      if (!name) return;
      if (!totalItems.has(name)) totalItems.set(name, 0);
      totalItems.set(name, totalItems.get(name) + count);
    };

    if (validA && !validB) {
      add(a, qty);
    } else if (!validA && validB) {
      add(b, qty * 2);
    } else if (validA && validB) {
      add(a, qty);
      add(b, qty);
    }
  }

  const specialsByLabel = new Map();
  const normalItems = [];

  for (const [name, count] of totalItems.entries()) {
    const row = rows.find(r => r[1] === name);
    if (!row) continue;
    const tag = row[3];
    const normalPriceRow = row.slice(15, 30);
    const priceIdx = priceHeaders.indexOf(payMethod);
    const unitPrice = parseFloat(normalPriceRow[priceIdx] || 0);

    if (tag && labelMap.includes(tag)) {
      const colIdx = labelMap.indexOf(tag);
      const allowedMethods = (payMethodMap[colIdx] || '').split('ã€');
      if (allowedMethods.includes(payMethod)) {
        if (!specialsByLabel.has(tag)) specialsByLabel.set(tag, []);
        specialsByLabel.get(tag).push({ price: unitPrice, count });
        continue;
      }
    }

    normalItems.push({ price: unitPrice, count });
  }

  let total = 0;
  for (const { price, count } of normalItems) total += price * count;

  for (const [tag, items] of specialsByLabel.entries()) {
    const colIdx = labelMap.indexOf(tag);
    const comboQty = parseInt(comboQtyMap[colIdx] || 0);
    const comboPrice = parseFloat(specialPriceMap[colIdx] || 0);
    const allUnits = [];
    for (const { price, count } of items) {
      for (let i = 0; i < count; i++) allUnits.push(price);
    }
    allUnits.sort((a, b) => b - a);
    const comboCount = Math.floor(allUnits.length / comboQty);
    total += comboCount * comboPrice;
    const remainder = allUnits.slice(comboCount * comboQty);
    for (const p of remainder) total += p;
  }

  return Math.round(total * 10) / 10;
}
// ---- æ–°å¢ç¨ç«‹æŠ˜æ‰£è¨ˆç®—ç³»çµ± (é›†é»å¡ + æ»¿ä»½æŠ˜) ----

function buildPortions(groupCard) {
  if (!window.gridData) return [];
  const grid = window.gridData;
  const rows = grid.slice(10, 105);
  const labelMap = grid[0];
  const comboQtyMap = grid[1];
  const specialPriceMap = grid[2];
  const payMethodMap = grid[3];
  const fullSetSpecialEligibilityRow = (grid[4] || []);
  const priceHeaders = grid[6].slice(15, 30);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';

  // åŠ æ¬Šå¾Œçš„ item æ•¸é‡ï¼ˆA/B è¦å‰‡ï¼‰
  const totalItems = new Map();
  for (const card of orderCards) {
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || '1');
    const a = selects[1]?.value;
    const b = selects[2]?.value;
    const isValid = name => rows.some(r => r[1] === name);
    const validA = a && isValid(a);
    const validB = b && isValid(b);
    const add = (name, count) => {
      if (!name) return;
      totalItems.set(name, (totalItems.get(name) || 0) + count);
    };
    if (validA && !validB) {
      add(a, qty);
    } else if (!validA && validB) {
      add(b, qty * 2);
    } else if (validA && validB) {
      add(a, qty);
      add(b, qty);
    }
  }

  // ç‰¹åƒ¹ vs å¸¸åƒ¹ï¼ˆå¸¸åƒ¹å†ä¾ AF æ¬„æ‹†å‡ºå¯æŠ˜èˆ‡ä¸å¯æŠ˜ï¼‰
  const specialsByLabel = new Map();
  const discountableNormalItems = [];
  const nonDiscountableNormalItems = [];

  for (const [name, count] of totalItems.entries()) {
    const row = rows.find(r => r[1] === name);
    if (!row) continue;
    const tag = row[3];
    const normalPriceRow = row.slice(15, 30);
    const priceIdx = priceHeaders.indexOf(payMethod);
    const unitPrice = parseFloat(normalPriceRow[priceIdx] || 0);

    // ç‰¹åƒ¹å“é‚è¼¯
    if (tag && labelMap.includes(tag)) {
      const colIdx = labelMap.indexOf(tag);
      const allowedMethods = (payMethodMap[colIdx] || '').split('ã€');
      if (allowedMethods.includes(payMethod)) {
        if (!specialsByLabel.has(tag)) specialsByLabel.set(tag, []);
        specialsByLabel.get(tag).push({ price: unitPrice, count, row });
        continue;
      }
    }

    // å¸¸åƒ¹å“ä¾ AF æ¬„åˆ¤å®šæ˜¯å¦å¯æŠ˜ï¼ˆrow[31] æ˜¯ AF æ¬„ï¼‰
    const afFlag = ((row[31] || '') + '').trim();
    if (afFlag === 'æ˜¯') {
      discountableNormalItems.push({ price: unitPrice, count, row });
    } else {
      nonDiscountableNormalItems.push({ price: unitPrice, count, row });
    }
  }

  const portions = [];
  // ç‰¹åƒ¹çµ„åˆï¼ˆå«é¤˜æ•¸é€€å›ï¼‰ï¼Œéƒ½å¯æŠ˜
  // ç‰¹åƒ¹çµ„åˆï¼ˆå«é¤˜æ•¸é€€å›ï¼‰ï¼Œä¾ B5~O5 æ±ºå®šæ˜¯å¦å¯åƒåŠ æ»¿ä»½æŠ˜æ‰£
  for (const [tag, items] of specialsByLabel.entries()) {
    const colIdx = labelMap.indexOf(tag);
    const comboQty = parseInt(comboQtyMap[colIdx] || 0) || 0;
    const comboPrice = parseFloat(specialPriceMap[colIdx] || 0) || 0;

    // å»ºå‡ºæ¯ä¸€å€‹å–®ä½ï¼ˆä¿ç•™ row ä»¥ä¾¿å¾ŒçºŒå¸¸åƒ¹åˆ¤å®šï¼‰
    const allUnits = [];
    for (const { price, count, row } of items) {
      for (let i = 0; i < count; i++) allUnits.push({ price, row });
    }
    allUnits.sort((a, b) => b.price - a.price);

    // åˆ¤æ–·è©²ç‰¹åƒ¹æ¨™ç±¤æ˜¯å¦æœ‰è³‡æ ¼åƒåŠ æ»¿ä»½æŠ˜æ‰£ï¼ˆB5~O5ï¼‰
    const specialFullSetFlag = (((fullSetSpecialEligibilityRow[colIdx] || '') + '').trim() === 'æ˜¯');

    if (comboQty > 0) {
      const comboCount = Math.floor(allUnits.length / comboQty);
      for (let i = 0; i < comboCount; i++) {
        portions.push({
          price: comboPrice,
          type: 'special',
          label: tag,
          discountable: specialFullSetFlag
        });
      }
      const remainderUnits = allUnits.slice(comboCount * comboQty);
      for (const { price, row } of remainderUnits) {
        const afFlag = (((row[31] || '') + '').trim() === 'æ˜¯');
        const targetArr = afFlag ? discountableNormalItems : nonDiscountableNormalItems;
        const name = row[1];
        const existing = targetArr.find(e => (e.row && e.row[1]) === name);
        if (existing) {
          existing.count = (existing.count || 1) + 1;
        } else {
          targetArr.push({ price, count: 1, row });
        }
      }
    } else {
      // å¦‚æœ comboQty ç‚º 0ï¼Œæ•´å€‹æ¨™ç±¤è¦–ç‚ºå¸¸åƒ¹è™•ç†
      for (const { price, row } of allUnits) {
        const afFlag = (((row[31] || '') + '').trim() === 'æ˜¯');
        const targetArr = afFlag ? discountableNormalItems : nonDiscountableNormalItems;
        const name = row[1];
        const existing = targetArr.find(e => (e.row && e.row[1]) === name);
        if (existing) {
          existing.count = (existing.count || 1) + 1;
        } else {
          targetArr.push({ price, count: 1, row });
        }
      }
    }
  }


  // å¸¸åƒ¹å¯æŠ˜éƒ¨åˆ†
  for (const { price, count, row } of discountableNormalItems) {
    const perPortionQty = parseInt((row[30] || 0)) || 1;
    const fullPortions = Math.floor(count / perPortionQty);
    const remainderUnits = count % perPortionQty;
    for (let i = 0; i < fullPortions; i++) {
      portions.push({
        price: price * perPortionQty,
        type: 'normal',
        label: null,
        isFullPortion: true,
        discountable: true,
        row: row
      });
    }
    if (remainderUnits > 0) {
      portions.push({
        price: price * remainderUnits,
        type: 'normal',
        label: null,
        isFullPortion: false,
        remainder: remainderUnits,
        discountable: true,
        row: row
      });
    }
  }

  // å¸¸åƒ¹ä¸å¯æŠ˜éƒ¨åˆ†ï¼ˆä»å‡ºç¾åœ¨é‡‘é¡ï¼Œä½† discountable: falseï¼‰
  for (const { price, count, row } of nonDiscountableNormalItems) {
    const perPortionQty = parseInt((row[30] || 0)) || 1;
    const fullPortions = Math.floor(count / perPortionQty);
    const remainderUnits = count % perPortionQty;
    for (let i = 0; i < fullPortions; i++) {
      portions.push({
        price: price * perPortionQty,
        type: 'normal',
        label: null,
        isFullPortion: true,
        discountable: false,
        row: row
      });
    }
    if (remainderUnits > 0) {
      portions.push({
        price: price * remainderUnits,
        type: 'normal',
        label: null,
        isFullPortion: false,
        remainder: remainderUnits,
        discountable: false,
        row: row
      });
    }
  }

  // ä¾åƒ¹æ ¼é«˜è‡³ä½æ’åº
  portions.sort((a, b) => b.price - a.price);
  return portions;
}


function applyPointCardDiscount(portions, cardCount, perCardCap) {
  let discount = 0;
  let usedCards = 0;
  const used = new Set();
  for (let c = 0; c < cardCount; c++) {
    const idx = portions.findIndex((p, i) => !used.has(i) && p.price <= perCardCap);
    if (idx === -1) break;
    discount += portions[idx].price;
    used.add(idx);
    usedCards++;
  }
  const remaining = portions.filter((_, i) => !used.has(i));
  return { discount, remaining, usedCards };
}

function applyFullPortionDiscount(portions, X, Y) {
  let discount = 0;
  let freeCount = 0;
  if (X <= 0 || Y <= 0) return { discount, freeCount };
  // æ¯ X ä»½ä¸€çµ„ï¼Œè©²çµ„æœ€å¾Œ Y ä»½å…è²»ï¼Œä½†åƒ…é™å®Œæ•´çµ„
  for (let blockStart = 0; blockStart + X <= portions.length; blockStart += X) {
    const block = portions.slice(blockStart, blockStart + X);
    for (let j = X - Y; j < X; j++) {
      discount += block[j].price;
      freeCount++;
    }
  }
  return { discount, freeCount };
}

function getPaymentWeight(groupCard) {
  if (!window.gridData) return 1;
  const grid = window.gridData;
  const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';
  const priceHeaders = grid[6].slice(15, 30);
  const weightRow = (grid[8] || []).slice(15, 30);
  const idx = priceHeaders.indexOf(payMethod);
  if (idx === -1) return 1;
  const w = parseFloat(weightRow[idx] || 1);
  return isNaN(w) ? 1 : w;
}


function computeIndependentDiscounts(groupCard) {
  const orderAmount = calculateTotalAmount(groupCard);
  const allPortions = buildPortions(groupCard);
  // åˆ¤å®šæ”¯ä»˜æ–¹å¼æ˜¯å¦æœ‰æŠ˜æ‰£è³‡æ ¼ï¼ˆåƒè€ƒ P5~AD5ï¼Œgrid index 4 å°æ‡‰ Excel ç¬¬5åˆ—ï¼‰
  const priceHeaders = (window.gridData && window.gridData[6] || []).slice(15, 30);
  const eligibilityRow = (window.gridData && window.gridData[4] || []).slice(15, 30);
  const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';
  let discountAllowed = true;
  const idx = priceHeaders.indexOf(payMethod);
  if (idx === -1) discountAllowed = false;
  else if (((eligibilityRow[idx] || '') + '').trim() !== 'æ˜¯') discountAllowed = false;

  // åˆ†å‡ºå¯æŠ˜èˆ‡ä¸å¯æŠ˜
  const eligiblePortions = allPortions.filter(p => p.discountable !== false);
  const ineligiblePortions = allPortions.filter(p => p.discountable === false);

  // å–é›†é»å¡è³‡è¨Š
  let pointCardCap = 0, pointCardCount = 0;
  const pointCardLabel = [...document.querySelectorAll('label')].find(l => l.textContent.includes('é»å¡æŠ˜æŠµä¸Šé™'));
  if (pointCardLabel) {
    const input = pointCardLabel.querySelector('input');
    pointCardCap = parseFloat(input?.value || 0);
  }
  const exchangeLabel = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('é›†é»å¡å…Œæ›æ•¸é‡'));
  if (exchangeLabel) {
    const input = exchangeLabel.querySelector('input');
    pointCardCount = parseInt(input?.value || 0);
  }

  let pointCardDiscount = 0, usedCards = 0;
  let remainingEligible = eligiblePortions;

  if (discountAllowed) {
    const resPoint = applyPointCardDiscount(remainingEligible, pointCardCount, pointCardCap);
    pointCardDiscount = resPoint.discount;
    remainingEligible = resPoint.remaining;
    usedCards = resPoint.usedCards;
  }

  let fullPortionDiscount = 0, freeCount = 0;
  let fullX = 0, fullY = 0;
  const fullPortionLabel = [...document.querySelectorAll('label')].find(l => l.textContent.includes('ä»½æŠ˜') && !l.textContent.includes('é»å¡æŠ˜æŠµ'));
  if (fullPortionLabel) {
    const inputs = fullPortionLabel.querySelectorAll('input');
    if (inputs.length >= 2) {
      fullX = parseInt(inputs[0]?.value || 0);
      fullY = parseInt(inputs[1]?.value || 0);
    }
  }

  if (discountAllowed) {
    const resFull = applyFullPortionDiscount(remainingEligible, fullX, fullY);
    fullPortionDiscount = resFull.discount;
    freeCount = resFull.freeCount;
  }

  const adjustment = parseFloat(groupCard.querySelector('.adjustInput')?.value || 0) || 0;
  const paymentWeight = getPaymentWeight(groupCard);
  const intermediate = orderAmount - pointCardDiscount - fullPortionDiscount + adjustment;
  const checkout = Math.round(intermediate * paymentWeight * 100) / 100;
  return {
    orderAmount,
    pointCard: { usedCards, discount: pointCardDiscount },
    fullPortion: { freeCount, discount: fullPortionDiscount },
    adjustment,
    paymentWeight,
    checkout,
    points: computePoints(groupCard, {
      orderAmount,
      pointCard: { usedCards, discount: pointCardDiscount },
      fullPortion: { freeCount, discount: fullPortionDiscount },
      adjustment,
      paymentWeight,
      checkout
    })
  };
}


// ---- æ–°å¢é»æ•¸ç™¼æ”¾è¨ˆç®— ----
function computePoints(groupCard, info) {
  if (!window.gridData) return { fullCyclePoints:0, leftoverPoints:0, containerPoints:0, totalPoints:0 };
  const grid = window.gridData;
  // è®€ UI çš„é–€æª»ï¼šæ»¿Nå…ƒNé»
  let moneyThreshold = 0, pointsPerMoney = 0;
  const moneyLabel = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('å…ƒ') && l.textContent.includes('é»'));
  if (moneyLabel) {
    const inputs = moneyLabel.querySelectorAll('input');
    if (inputs.length >= 2) {
      moneyThreshold = parseFloat(inputs[0]?.value || 0);
      pointsPerMoney = parseFloat(inputs[1]?.value || 0);
    }
  }
  // è®€æ»¿Nä»½ä¹˜Nå€ï¼ˆå‰©é¤˜åŠ æ¬Šï¼‰
  let setThreshold = 0, setMultiplier = 1;
  const setLabel = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('ä»½ä¹˜'));
  if (setLabel) {
    const inputs = setLabel.querySelectorAll('input');
    if (inputs.length >= 2) {
      setThreshold = parseFloat(inputs[0]?.value || 0);
      setMultiplier = parseFloat(inputs[1]?.value || 0);
    }
  }
  // è®€æ»¿ä»½æŠ˜çš„ X (æ¯çµ„å¤§å°) èˆ‡ Y (æ¯çµ„å…è²»ä»½æ•¸)
  let fullX = 0, fullY = 0;
  const fullPortionLabel = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('ä»½æŠ˜') && !l.textContent.includes('é»å¡æŠ˜æŠµ'));
  if (fullPortionLabel) {
    const inputs = fullPortionLabel.querySelectorAll('input');
    if (inputs.length >= 2) {
      fullX = parseInt(inputs[0]?.value || 0);
      fullY = parseInt(inputs[1]?.value || 0);
    }
  }
  // è¨ˆç®—å®Œæ•´å¾ªç’°æ•¸ï¼ˆfreeCount / fullYï¼‰
  const freeCount = info.fullPortion.freeCount || 0;
  const cycles = fullY > 0 ? Math.floor(freeCount / fullY) : 0;
  // æ¯ä¸€å€‹å¾ªç’°çµ¦çš„é»æ•¸ = pointsPerMoney
  const fullCyclePoints = cycles * pointsPerMoney;

  // å–å¾—æ‰€æœ‰ portions
  const allPortions = buildPortions(groupCard);
  // å…ˆè™•ç†è¢«é›†é»å¡æŠ˜æ‰çš„ portionsï¼šå¾åŸæœ¬åƒåŠ æ»¿ä»½æŠ˜æ‰£çš„ eligiblePortions ä¸­ç§»é™¤é»å¡ä½¿ç”¨æ‰çš„é‚£éƒ¨åˆ†
  const eligiblePortions = allPortions.filter(p => p.discountable !== false);
  // å–é›†é»å¡è³‡è¨Šï¼ˆç‚ºäº†æ’é™¤å·²è¢«é»å¡æŠ˜æŠµçš„ portionï¼‰
  let pointCardCountLocal = 0, pointCardCapLocal = 0;
  const pointCardLabelLocal = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('é›†é»å¡å…Œæ›æ•¸é‡'));
  if (pointCardLabelLocal) {
    const input = pointCardLabelLocal.querySelector('input');
    pointCardCountLocal = parseInt(input?.value || 0);
  }
  const pointCardCapLabelLocal = [...document.querySelectorAll('label')].find(l => l.textContent.includes('é»å¡æŠ˜æŠµä¸Šé™'));
  if (pointCardCapLabelLocal) {
    const input = pointCardCapLabelLocal.querySelector('input');
    pointCardCapLocal = parseFloat(input?.value || 0);
  }
  // apply point card discount to eligiblePortions to get remaining eligible after point card removal
  const resPointLocal = applyPointCardDiscount(eligiblePortions, pointCardCountLocal, pointCardCapLocal);
  const remainingEligibleAfterPointCard = resPointLocal.remaining;
  // å–å‡ºæ»¿ä»½å·²ä½¿ç”¨çš„ portionsï¼ˆæ¯å€‹å¾ªç’° consume fullX ä»½ï¼‰ï¼Œé€™è£¡ä½¿ç”¨ remainingEligibleAfterPointCard
  const usedCount = cycles * fullX;
  const leftoverFromEligible = remainingEligibleAfterPointCard.slice(usedCount);
  // ä¸€é–‹å§‹æ²’æœ‰åƒåŠ æ»¿ä»½æŠ˜çš„ï¼ˆä¸å¯æŠ˜éƒ¨åˆ†ï¼‰
  const neverIncluded = allPortions.filter(p => p.discountable === false);
  // åˆä½µç‚ºå‰©ä¸‹è¦å†åšé»æ•¸è³‡æ ¼åˆ¤æ–·çš„ pool
  const leftoverPool = [...leftoverFromEligible, ...neverIncluded];

  // åˆ¤æ–·æŸä¸€ portion æ˜¯å¦æœ‰é»æ•¸è³‡æ ¼
  function portionEligibleForPoints(p) {
    if (!grid) return false;
    // ç‰¹åƒ¹å“ç”¨æ¨™ç±¤å»çœ‹ B6~O6ï¼ˆå‡è¨­åœ¨ grid[0] æ‰¾åˆ° tag å†çœ‹ row 6 æ˜¯å¦ç‚º 'æ˜¯'ï¼‰
    if (p.type === 'special') {
      const tag = p.label;
      if (!tag) return false;
      const labelMap = grid[0] || [];
      const idx = labelMap.indexOf(tag);
      if (idx === -1) return false;
      const row6 = (grid[5] || []);
      return ((row6[idx] || '') + '').trim() === 'æ˜¯';
    }
    // å¸¸åƒ¹ï¼ˆçœ‹ AG æ¬„ä½ï¼‰
    if (p.row) {
      const agFlag = ((p.row[32] || '') + '').trim();
      return agFlag === 'æ˜¯';
    }
    return false;
  }

  // è¨ˆç®—å‰©é¤˜ç¬¦åˆè³‡æ ¼çš„é‡‘é¡èˆ‡ä»½æ•¸
  let leftoverAmount = 0;
  let leftoverSetCount = 0;
  leftoverPool.forEach(p => {
    if (!portionEligibleForPoints(p)) return;
    leftoverAmount += p.price || 0;
    if (p.isFullPortion) leftoverSetCount += 1;
    else if (p.remainder) leftoverSetCount += p.remainder;
    else leftoverSetCount += 1;
  });

  // åŸºåº•é»æ•¸ï¼ˆæ»¿Nå…ƒNé»ï¼‰
  let leftoverPoints = 0;
  if (moneyThreshold > 0) {
    const basePoints = Math.floor(leftoverAmount / moneyThreshold) * pointsPerMoney;
    if (leftoverSetCount >= setThreshold && setThreshold > 0) {
      leftoverPoints = basePoints * setMultiplier;
    } else {
      leftoverPoints = basePoints;
    }
  }

  // è‡ªå‚™å®¹å™¨ï¼ˆåŠ ç¢¼ï¼‰
  let containerPoints = 0;
  const selfContainerChecked = !!groupCard.querySelector('input[type="checkbox"]')?.checked;
  if (selfContainerChecked && pointsPerMoney > 0) {
    containerPoints = pointsPerMoney;
  }

  let paymentMethodEligible = true;
  if (window.gridData) {
    const grid = window.gridData;
    const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';
    const priceHeaders = (grid[6] || []).slice(15, 30);
    const methodIdx = priceHeaders.indexOf(payMethod);
    if (methodIdx !== -1) {
      const eligibilityRow = (grid[2] || []).slice(15, 30);
      if (((eligibilityRow[methodIdx] || '') + '').trim() !== 'æ˜¯') {
        paymentMethodEligible = false;
      }
    }
  }
  if (!paymentMethodEligible) {
    return { fullCyclePoints:0, leftoverPoints:0, containerPoints:0, totalPoints:0 };
  }
  const totalPoints = fullCyclePoints + leftoverPoints + containerPoints;
  return { fullCyclePoints, leftoverPoints, containerPoints, totalPoints };
}


// ---- æ–°å¢æ•´æ—¥è¨‚å–®çµç®—åŠŸèƒ½ ----
function formatMoney(n){ return (Math.round(n*100)/100).toFixed(2); }


function computeGroupCost(groupCard){
  if (!window.gridData) return 0;
  const grid = window.gridData;
  const rows = grid.slice(10, 105);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const totalItems = new Map();
  for (const card of orderCards){
    const selects = card.querySelectorAll('select');
    const qtyInput = card.querySelector('input[type="number"]');
    const qty = parseInt(qtyInput?.value || '1');
    const itemA = selects[1]?.value;
    const itemB = selects[2]?.value;
    const isValid = name => rows.some(r => r[1] === name);
    const add = (name, count) => {
      if (!name) return;
      totalItems.set(name, (totalItems.get(name) || 0) + count);
    };
    const validA = itemA && isValid(itemA);
    const validB = itemB && isValid(itemB);
    if (validA && !validB){
      add(itemA, qty);
    } else if (!validA && validB){
      add(itemB, qty * 2);
    } else if (validA && validB){
      add(itemA, qty);
      add(itemB, qty);
    }
  }
  let totalCost=0;
  for (const [name, count] of totalItems.entries()){
    const row = rows.find(r => r[1] === name);
    if (!row) continue;
    const costPerUnit = parseFloat(row[4]) || 0;
    totalCost += costPerUnit * count;
  }
  return Math.round(totalCost * 100)/100;
}


function updateDailySummary(){
  const groupCards = [...document.querySelectorAll('.groupCard')];
  let totalOrder=0;
  let totalPointCardUsed=0;
  let totalPointCardDiscount=0;
  let totalFullPortionCount=0;
  let totalFullPortionDiscount=0;
  let totalAdjustment=0;
  let totalCheckout=0;
  let totalPoints=0;
  let waitingMinutes = 0;
  let totalSelfContainerChecked=0;
  const paymentMethodTotals = {};
  const paymentMethodCostTotals = {};
  let totalCost = 0;
  for(const group of groupCards){
    const statusSelect = group.querySelector('.groupHeader > select');
    if (statusSelect && statusSelect.value === 'å–æ¶ˆè¨‚å–®') continue;

    // accumulate waiting time for orders that are waiting to be produced
    if (statusSelect && (statusSelect.value === 'æœªçµå¾…è£½' || statusSelect.value === 'å·²çµå¾…è£½')) {
      const prod = computeProductionTime(group);
      waitingMinutes += (prod.hours * 60 + prod.minutes);
    }
    const info = computeIndependentDiscounts(group);
    totalOrder += (info.orderAmount || 0);
    totalPointCardUsed += (info.pointCard?.usedCards || 0);
    totalPointCardDiscount += (info.pointCard?.discount || 0);
    totalFullPortionCount += (info.fullPortion?.freeCount || 0);
    totalFullPortionDiscount += (info.fullPortion?.discount || 0);
    totalAdjustment += (info.adjustment || 0);
    totalCheckout += (info.checkout || 0);
    totalPoints += (info.points?.totalPoints || 0);
    const selfContainerCheckbox = [...group.querySelectorAll('label')].find(l=> l.textContent.includes('è‡ªå‚™å®¹å™¨'))?.querySelector('input[type="checkbox"]');
    if (selfContainerCheckbox?.checked) totalSelfContainerChecked++;
    const groupCost = computeGroupCost(group);
    totalCost += groupCost;
    // payment method grouping
    const paymentSelect = [...group.querySelectorAll('select')].find(s=> s.options[0] && s.options[0].textContent==='æ”¯ä»˜æ–¹å¼');
    let pm = '';
    if(paymentSelect){
      const val = paymentSelect.value;
      if(val && val.trim()!=='' && val.trim()!=='æ”¯ä»˜æ–¹å¼') pm = val;
    }
    if(pm){
      paymentMethodTotals[pm] = (paymentMethodTotals[pm]||0) + (info.checkout||0);
      paymentMethodCostTotals[pm] = (paymentMethodCostTotals[pm]||0) + groupCost;
    }
  }
  const totalsEl = document.getElementById('dailyTotals');
  const breakdownEl = document.getElementById('paymentBreakdown');
  const overallProfitPercent = totalCheckout ? (1 - (totalCost / totalCheckout)) * 100 : 0;
  const overallProfitText = totalCheckout ? `(${overallProfitPercent.toFixed(2)}%)` : '(0.00%)';
  const waitHours = Math.floor(waitingMinutes/60);
  const waitMins = waitingMinutes % 60;
  const waitingStr = `ç›®å‰ç­‰å¾…æ™‚é–“${waitHours}æ™‚${waitMins}åˆ†ï¼›`;
  const totalSummary = `${waitingStr}æ•´æ—¥åˆè¨ˆï¼šè¨‚å–®é‡‘é¡ ${formatMoney(totalOrder)} å…ƒï¼›é›†é»å¡å…Œæ› ${formatMoney(totalPointCardDiscount)} å…ƒï¼›æ»¿ä»½æŠ˜ ${formatMoney(totalFullPortionDiscount)} å…ƒï¼›é‡‘é¡èª¿æ•´ ${formatMoney(totalAdjustment)} å…ƒï¼›çµå¸³é‡‘é¡ ${formatMoney(totalCheckout)} å…ƒ${overallProfitText}ï¼›${Math.round(totalPoints)} é»ï¼›è‡ªå‚™å®¹å™¨ ${totalSelfContainerChecked}`;
  if(totalsEl) totalsEl.textContent = totalSummary;
  const parts = [];
  for(const m in paymentMethodTotals){
    if(Object.hasOwn(paymentMethodTotals,m)){
      const pmCheckout = paymentMethodTotals[m];
      const pmCost = paymentMethodCostTotals[m] || 0;
      const pmProfitPercent = pmCheckout ? (1 - (pmCost / pmCheckout)) * 100 : 0;
      parts.push(`${m}: ${formatMoney(pmCheckout)} å…ƒ(${pmProfitPercent.toFixed(2)}%)`);
    }
  }
  if(breakdownEl) breakdownEl.textContent = parts.length ? 'æ”¯ä»˜æ–¹å¼å°è¨ˆï¼š' + parts.join('ï¼›') : '';
}


// æ¯æ¬¡ summary æ›´æ–°å¾Œä¹Ÿ update daily
function updateAllDailySummary(){
  updateDailySummary();
}


// ---- çµæŸç¨ç«‹æŠ˜æ‰£ç³»çµ± ----

// âœ… ä¹¾æ·¨çš„ summary updaterï¼ˆåªç•™é€™å€‹ä¸€å€‹å¯¦ä½œï¼‰

// âœ… ä¹¾æ·¨çš„ summary updaterï¼ˆæ“´å……è¨‚å–®è³‡è¨Šï¼šä¾†æºã€æ”¯ä»˜æ–¹å¼ã€è¨»è¨˜ã€å¤–é€ã€æ™‚é–“ï¼‰

// === æ–°å¢ï¼šè£½ä½œæ™‚é–“ä¼°ç®— helper ===
function getOvenBatchSeconds() {
  const label = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('çƒ¤ç›¤è¨ˆæ™‚'));
  if (!label) return 0;
  const inputs = label.querySelectorAll('input');
  let min = parseInt(inputs[0]?.value || '0', 10);
  let sec = parseInt(inputs[1]?.value || '0', 10);
  if (isNaN(min)) min = 0;
  if (isNaN(sec)) sec = 0;
  return (min * 60) + sec;
}
function getPerPieceSeconds() {
  const label = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('é¡†ç§’'));
  if (!label) return 0;
  const input = label.querySelector('input');
  const sec = parseInt(input?.value || '0', 10);
  if (isNaN(sec)) return 0;
  return sec;
}
function computeProductionTime(groupCard){
  const perPieceSeconds = getPerPieceSeconds();
  const ovenBatchSeconds = getOvenBatchSeconds();
  let totalPieces = 0;
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];

  // å»ºç«‹å¾ B æ¬„å•†å“åç¨±å°æ‡‰åˆ° A æ¬„å“é …é¡åˆ¥çš„ mapï¼ˆA11~A106 å°æ‡‰ index 10~105ï¼‰
  const targetCategories = new Set(['é›è›‹ç³•', 'é¤…ä¹¾']);
  let productCategoryMap = null;
  if (window.gridData) {
    const rows = window.gridData.slice(10, 106); // åŒ…å« A11~A106
    productCategoryMap = new Map(rows.map(r => [r[1], (r[0] || '').trim()]));
  }

  function isTargetProduct(name){
    if (!name) return false;
    const normalized = name.trim();
    if (normalized.includes('é›è›‹ç³•') || normalized.includes('é¤…ä¹¾')) return true;
    if (productCategoryMap) {
      const category = productCategoryMap.get(normalized);
      if (category && targetCategories.has(category)) return true;
    }
    return false;
  }

  for (const card of orderCards){
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type=\"number\"]')?.value || '1', 10);
    const a = selects[1]?.value || '';
    const b = selects[2]?.value || '';
    const validA = isTargetProduct(a);
    const validB = isTargetProduct(b);
    if (validA && !validB){
      totalPieces += qty;
    } else if (!validA && validB){
      totalPieces += qty * 2;
    } else if (validA && validB){
      totalPieces += qty * 2;
    }
  }

  const processingSeconds = totalPieces * perPieceSeconds;
  const batches = Math.ceil(totalPieces / 12);
  const ovenSecondsTotal = batches * ovenBatchSeconds;
  const totalSeconds = processingSeconds + ovenSecondsTotal;
  const totalMinutes = Math.ceil(totalSeconds / 60);
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  return { hours, minutes, totalPieces };
}

function bindSummaryUpdater(groupCard) {
  const getItemPortionSummary = window.getItemPortionSummary || (() => '');
  const summaryDiv = groupCard.querySelector('.summaryText');
  const summaryBox = groupCard.querySelector('.summaryBoxText');
  const inputs = groupCard.querySelectorAll('select, input[type="number"]');
  let lastSummary = '', lastBox = '';

  function update() {
    let portionSummary = getItemPortionSummary(groupCard);
    const baseSummary = getSummaryText(groupCard);
    const prodTime = computeProductionTime(groupCard);
    let itemSummaryLine = baseSummary;
    if (prodTime.totalPieces > 0) {
      if (portionSummary) {
        portionSummary += ` é è¨ˆè£½ä½œæ™‚é–“${prodTime.hours}æ™‚${String(prodTime.minutes).padStart(2,'0')}åˆ†`;
      } else {
        itemSummaryLine += ` é è¨ˆè£½ä½œæ™‚é–“${prodTime.hours}æ™‚${String(prodTime.minutes).padStart(2,'0')}åˆ†`;
      }
    }

    const boxSummary = getBoxSummaryText(groupCard);
    const info = computeIndependentDiscounts(groupCard);
    const fmt = n => (Math.round(n * 100) / 100).toFixed(2);
    const orderAmountText = fmt(info.orderAmount);
    const pointCardCount = info.pointCard.usedCards;
    const pointCardDiscount = fmt(info.pointCard.discount);
    const fullPortionCount = info.fullPortion.freeCount;
    const fullPortionDiscount = fmt(info.fullPortion.discount);
    const adjustmentText = fmt(info.adjustment);
    const checkoutText = fmt(info.checkout);
    let pointsText = `é»æ•¸ç™¼æ”¾ ${info.points?.totalPoints || 0} é»`;
    if (info.points?.containerPoints > 0) {
      pointsText += ' (è‡ªå‚™å®¹å™¨)';
    }
    const summaryMain = `è¨‚å–®é‡‘é¡ ${orderAmountText} å…ƒï¼›é›†é»å¡å…Œæ› ${pointCardCount} ä»½ ${pointCardDiscount} å…ƒï¼›æ»¿ä»½æŠ˜ ${fullPortionCount} ä»½ ${fullPortionDiscount} å…ƒï¼›é‡‘é¡èª¿æ•´ ${adjustmentText} å…ƒï¼›çµå¸³é‡‘é¡ ${checkoutText} å…ƒï¼›${pointsText}`;

    let extraParts = [];
    // é¡§å®¢ä¾†æº
    
    // é¡§å®¢ä¾†æºèˆ‡æ™‚é–“ï¼ˆæ™‚é–“åœ¨å‰ï¼‰
    let customerSourcePart = '';
    const sourceSelect = [...groupCard.querySelectorAll('select')].find(s => s.options[0] && s.options[0].textContent.trim() === 'é¡§å®¢ä¾†æº');
    let customerSourceValue = '';
    if (sourceSelect) {
      const val = sourceSelect.value;
      if (val && val.trim() !== '' && val.trim() !== 'é¡§å®¢ä¾†æº') customerSourceValue = val.trim();
    }
    const sourceTime = groupCard.dataset.customerSourceTime;
    if (customerSourceValue) {
      if (sourceTime) {
        customerSourcePart = `${sourceTime} ${customerSourceValue}`;
      } else {
        customerSourcePart = customerSourceValue;
      }
    }
    if (customerSourcePart) extraParts.push(customerSourcePart);

    // æ”¯ä»˜æ–¹å¼ï¼šæ’é™¤é è¨­ placeholder "æ”¯ä»˜æ–¹å¼"
    let paymentMethod = '';
    const paymentSelect = [...groupCard.querySelectorAll('select')].find(s => s.options[0] && s.options[0].textContent === 'æ”¯ä»˜æ–¹å¼');
    if (paymentSelect) {
      const val = paymentSelect.value;
      if (val && val.trim() !== '' && val.trim() !== 'æ”¯ä»˜æ–¹å¼') paymentMethod = val;
    }
    if (!paymentMethod) {
      const paymentLabel = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('æ”¯ä»˜æ–¹å¼'));
      if (paymentLabel) {
        const sel = paymentLabel.querySelector('select');
        const inp = paymentLabel.querySelector('input');
        const val = sel?.value || inp?.value || '';
        if (val && !val.includes('æ”¯ä»˜æ–¹å¼')) paymentMethod = val;
      }
    }
    if (paymentMethod) extraParts.push(paymentMethod);
    // è¨»è¨˜
    const note = [...groupCard.querySelectorAll('label')].find(l=>l.textContent.includes('è¨»è¨˜'))?.querySelector('input')?.value || '';
    if (note) extraParts.push(note);
    // å¤–é€è³‡è¨Š
    const deliveryInfoLabel = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('å¤–é€è³‡è¨Š'));
    const deliveryInfo = deliveryInfoLabel?.querySelector('input')?.value || '';
    // è¬å¹´è¡¨æ™‚é–“
    const timeVal = groupCard.querySelector('input[type=\\"datetime-local\\"]')?.value || '';
    let timelineText = '';
    if (timeVal) {
      const dt = new Date(timeVal);
      const pad = n => n.toString().padStart(2, '0');
      const dateStr = `${dt.getFullYear()}/${pad(dt.getMonth()+1)}/${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}`;
      if (deliveryInfo) {
        timelineText = `${dateStr}é€é”`;
      } else {
        timelineText = `${dateStr}å–é¤`;
      }
    }
    if (deliveryInfo) extraParts.push(deliveryInfo);
    if (timelineText) extraParts.push(timelineText);
    // é¡å¤–è£œå¼·è¬å¹´æ›†é¡¯ç¤ºï¼ˆè‹¥å‰é¢æ²’å‡ºç¾ä½† span æœ‰é¡¯ç¤ºï¼‰
    const pickupSpanEl = groupCard.querySelector('.pickupText');
    const deliverySpanEl = groupCard.querySelector('.deliveryText');
    if (pickupSpanEl && pickupSpanEl.style.display !== 'none' && pickupSpanEl.textContent.trim()) {
      if (!extraParts.includes(pickupSpanEl.textContent.trim())) extraParts.push(pickupSpanEl.textContent.trim());
    }
    if (deliverySpanEl && deliverySpanEl.style.display !== 'none' && deliverySpanEl.textContent.trim()) {
      if (!extraParts.includes(deliverySpanEl.textContent.trim())) extraParts.push(deliverySpanEl.textContent.trim());
    }


    const statusSelectForSummary = groupCard.querySelector('.groupHeader > select');
    let fullSummaryMain = summaryMain;
    if (statusSelectForSummary && statusSelectForSummary.value === 'å–æ¶ˆè¨‚å–®') {
      fullSummaryMain = 'å–æ¶ˆè¨‚å–® ' + summaryMain;
    }
    let full = fullSummaryMain;
    if (extraParts.length) full += '\n' + extraParts.join('ï¼›');
    if (portionSummary) {
      full += '\n' + portionSummary + '\n' + itemSummaryLine;
    } else {
      full += '\n' + itemSummaryLine;
    }
    if (full !== lastSummary) summaryDiv.textContent = lastSummary = full;
    if (boxSummary !== lastBox) summaryBox.textContent = lastBox = boxSummary;
    if (typeof updateDailySummary === 'function') updateDailySummary();
  }

  inputs.forEach(input => {
    input.addEventListener('change', update);
    input.addEventListener('input', update);
  });
  // è‡ªå‚™å®¹å™¨ checkbox ä¹Ÿè¦å³æ™‚æ›´æ–°
  const containerCheckbox = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('è‡ªå‚™å®¹å™¨'))?.querySelector('input[type="checkbox"]');
  if (containerCheckbox) {
    containerCheckbox.addEventListener('change', update);
  }
  // é¡å¤–ç›£è½ï¼šè¨»è¨˜ã€å¤–é€è³‡è¨Šã€æ™‚é–“
  const noteInput = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('è¨»è¨˜'))?.querySelector('input');
  const deliveryInput = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('å¤–é€è³‡è¨Š'))?.querySelector('input');
  const timeInput = groupCard.querySelector('input[type="datetime-local"]');
  [noteInput, deliveryInput, timeInput].forEach(el => {
    if (!el) return;
    el.addEventListener('input', update);
    el.addEventListener('change', update);
  });
  update();
}



// âœ… åƒ…èª¿æ•´æ‘˜è¦é¡¯ç¤ºé‡‘é¡ï¼ˆä¸å‹•å…¶ä»–é‚è¼¯ï¼‰

</script>


<script>
// é‡åšçš„ç©©å®šåŒ¯å‡º / åŒ¯å…¥ TXT åŠŸèƒ½ï¼ˆç‰ˆæœ¬å‡ç´š V1.01.28ï¼‰
document.addEventListener("DOMContentLoaded", () => {
  // ä¿ç•™ä¸€å€‹ä¹¾æ·¨çš„ group ç¯„æœ¬
  const container = window.findGroupContainer();
  const originalGroup = document.querySelector(".groupCard");
  let groupTemplate = null;
  if (originalGroup) {
    groupTemplate = originalGroup.cloneNode(true);
  }

  function gatherExportData() {
    const totalsEl = document.getElementById('dailyTotals');
    const breakdownEl = document.getElementById('paymentBreakdown');
    const dailySummaryText =
      (totalsEl?.textContent || '') +
      (breakdownEl?.textContent ? '\n' + breakdownEl.textContent : '');

    const groupsData = [...document.querySelectorAll('.groupCard')].map(group => {
      const name = group.querySelector('h3')?.textContent || '';
      const status = group.querySelector('.groupHeader > select')?.value || '';
      const customerSource = [...group.querySelectorAll('.rowLine select')]
        .find(s => s.options[0]?.textContent === 'é¡§å®¢ä¾†æº')?.value || '';
      const paymentMethod = [...group.querySelectorAll('.rowLine select')]
        .find(s => s.options[0]?.textContent === 'æ”¯ä»˜æ–¹å¼')?.value || '';
      const note = group.querySelector('input[placeholder="è¨»è¨˜"]')?.value || '';
      const datetime = group.querySelector('input[type="datetime-local"]')?.value || '';
      const deliveryInfo = [...group.querySelectorAll('label')]
        .find(l => l.textContent.includes('å¤–é€è³‡è¨Š'))?.querySelector('input')?.value || '';
      const getLabelInputValue = text =>
        [...group.querySelectorAll('label')]
          .find(l => l.textContent.includes(text))?.querySelector('input')?.value || '';
      const pointCards = getLabelInputValue('é›†é»å¡å…Œæ›æ•¸é‡');
      const adjustment = getLabelInputValue('é‡‘é¡èª¿æ•´');
      const selfContainer = !![...group.querySelectorAll('label')]
        .find(l => l.textContent.includes('è‡ªå‚™å®¹å™¨'))?.querySelector('input')?.checked;
      const customerSourceTime = group.dataset.customerSourceTime || '';
      const orders = [...group.querySelectorAll('.orderCard')].map(card => {
        const rowLines = card.querySelectorAll('.rowLine');
        const item = rowLines[0]?.querySelector('select')?.value || '';
        const quantity = rowLines[0]?.querySelector('input[type=\"number\"]')?.value || '';
        const productA = rowLines[1]?.querySelectorAll('select')[0]?.value || '';
        const productB = rowLines[1]?.querySelectorAll('select')[1]?.value || '';
        const accessories = Array.from(rowLines[1]?.querySelectorAll('select') || [])
          .slice(2, 8)
          .map(s => s.value || '');
        return { item, quantity, productA, productB, accessories };
      });

      return {
        name,
        status,
        customerSource,
        customerSourceTime,
        paymentMethod,
        note,
        datetime,
        deliveryInfo,
        pointCards,
        adjustment,
        selfContainer,
        orders
      };
    });

    return {
      exportedAt: new Date().toISOString(),
      dailySummary: dailySummaryText,
      groups: groupsData
    };
  }

  async function exportToTxt() {
    const exportObj = gatherExportData();
    let text = '';
    if (exportObj && exportObj.groups) {
      text += `æ•´æ—¥åˆè¨ˆï¼š${exportObj.dailySummary}\n\n`;
      for (const g of exportObj.groups) {
        text += `ç¬¬ ${g.name.replace(/ç¬¬\\s*/, '')} çµ„å®¢äººï¼ˆç‹€æ…‹ï¼š${g.status}ï¼‰ï¼š\n`;
        text += `  é¡§å®¢ä¾†æº: ${g.customerSource} ${g.customerSourceTime || ''}\n`;
        text += `  æ”¯ä»˜æ–¹å¼: ${g.paymentMethod}\n`;
        text += `  è¨»è¨˜: ${g.note}\n`;
        text += `  æ™‚é–“: ${g.datetime}\n`;
        text += `  å¤–é€è³‡è¨Š: ${g.deliveryInfo}\n`;
        text += `  é›†é»å¡å…Œæ›æ•¸é‡: ${g.pointCards}\n`;
        text += `  é‡‘é¡èª¿æ•´: ${g.adjustment}\n`;
        text += `  è‡ªå‚™å®¹å™¨: ${g.selfContainer}\n`;
        for (let i = 0; i < g.orders.length; i++) {
          const o = g.orders[i];
          const acc = o.accessories.filter(a => a).join('+');
          text += `  ç¬¬ ${i + 1} çµ„è¨‚å–®: å“é …=${o.item}, æ•¸é‡=${o.quantity}, å•†å“A=${o.productA}, å•†å“B=${o.productB}, é™„=${acc}\n`;
        }
        text += '\n';
      }
    }
    const exportObjFull = gatherExportData();
    text += `---JSON-EXPORT-START---\n${JSON.stringify(exportObjFull)}\n---JSON-EXPORT-END---\n`;

    if (window.showSaveFilePicker) {
      try {
        const opts = {
          suggestedName: `è¨‚å–®å‚™ä»½_${new Date().toISOString().slice(0, 10)}.txt`,
          types: [{
            description: 'Text file',
            accept: { 'text/plain': ['.txt'] }
          }]
        };
        const handle = await window.showSaveFilePicker(opts);
        const writable = await handle.createWritable();
        await writable.write(text);
        await writable.close();
        alert('åŒ¯å‡ºå®Œæˆï¼Œå·²å„²å­˜è‡³é¸å®šä½ç½®');
        return;
      } catch (e) {
        if (e.name === 'AbortError') {
          console.log('ä½¿ç”¨è€…å·²å–æ¶ˆåŒ¯å‡º');
          return;
        }
        console.warn('showSaveFilePicker failed, fallback to anchor download', e);
      }
    }
    const blob = new Blob([text], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `è¨‚å–®å‚™ä»½_${new Date().toISOString().slice(0, 10)}.txt`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 5000);
  }

  
  
  async function importFromTxt() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.txt,text/plain';
    input.addEventListener('change', async () => {
      const file = input.files[0];
      if (!file) return;
      const text = await file.text();
      const m = text.match(/---JSON-EXPORT-START---\s*([\s\S]*?)\s*---JSON-EXPORT-END---/);
      if (!m) { alert('æ‰¾ä¸åˆ°åŒ¯å‡ºæ ¼å¼ä¸­çš„ JSON è³‡è¨Š'); return; }
      let obj;
      try { obj = JSON.parse(m[1]); } catch (e) { alert('è§£æ JSON å¤±æ•—: ' + e); return; }

      // æ‰¾åˆ°ç¾¤çµ„å®¹å™¨ä¸¦æ¸…ç©º
      const container = window.findGroupContainer ? window.findGroupContainer() : document.querySelector('.groupsContainer');
      if (!container) { alert('æ‰¾ä¸åˆ°ç¾¤çµ„å®¹å™¨'); return; }
      document.querySelectorAll('.groupCard').forEach(g => g.remove());

      // é€çµ„åŒ¯å…¥å®¢äºº
      for (const g of obj.groups) {
        const addCustomerBtn = document.querySelector('.stickyBar .btn.add');
        if (!addCustomerBtn) { alert('æ‰¾ä¸åˆ°ã€Œæ–°å¢å®¢äººã€æŒ‰éˆ•'); break; }
        const prevCount = container.querySelectorAll('.groupCard').length;
        addCustomerBtn.click();
        // ç­‰å¾…æ–°ç¾¤çµ„ç¯€é»å‡ºç¾
        await new Promise(resolve => {
          const interval = setInterval(() => {
            const count = container.querySelectorAll('.groupCard').length;
            if (count > prevCount) {
              clearInterval(interval);
              resolve();
            }
          }, 50);
        });
        const groups = container.querySelectorAll('.groupCard');
        const newGroup = groups[groups.length - 1];
        if (!newGroup) { alert('ç„¡æ³•å»ºç«‹æ–°ç¾¤çµ„'); return; }

        // è¨­å®šç¾¤çµ„åç¨±
        const h3 = newGroup.querySelector('h3');
        if (h3) h3.textContent = g.name;

        // åˆå§‹åŒ–ç¾¤çµ„åŠŸèƒ½
        if (typeof initGroup === 'function') initGroup(newGroup);
        if (window.bindItemSelectLogic) window.bindItemSelectLogic(newGroup);
        if (typeof window.populatePaymentOptions === 'function') window.populatePaymentOptions(newGroup);
        if (typeof bindCopyButton === 'function') bindCopyButton(newGroup);
        if (typeof bindSummaryUpdater === 'function') bindSummaryUpdater(newGroup);

        // å¡«å…¥æ¬„ä½
        const statusSel = newGroup.querySelector('.groupHeader > select');
        if (statusSel) { statusSel.value = g.status; statusSel.dispatchEvent(new Event('change', { bubbles: true })); }
        const customerSourceSel = [...newGroup.querySelectorAll('.rowLine select')].find(s => s.options[0]?.textContent === 'é¡§å®¢ä¾†æº');
        if (customerSourceSel) { customerSourceSel.value = g.customerSource; customerSourceSel.dispatchEvent(new Event('change', { bubbles: true })); }
        const paymentSel = [...newGroup.querySelectorAll('.rowLine select')].find(s => s.options[0]?.textContent === 'æ”¯ä»˜æ–¹å¼');
        if (paymentSel) { paymentSel.value = g.paymentMethod; paymentSel.dispatchEvent(new Event('change', { bubbles: true })); }
        const noteInput = newGroup.querySelector('input[placeholder="è¨»è¨˜"]');
        if (noteInput) { noteInput.value = g.note; noteInput.dispatchEvent(new Event('input', { bubbles: true })); }
        const dtInput = newGroup.querySelector('input[type="datetime-local"]');
        if (dtInput) { dtInput.value = g.datetime; dtInput.dispatchEvent(new Event('change', { bubbles: true })); }
        const deliveryInput = [...newGroup.querySelectorAll('label')].find(l => l.textContent.includes('å¤–é€è³‡è¨Š'))?.querySelector('input');
        if (deliveryInput) { deliveryInput.value = g.deliveryInfo; deliveryInput.dispatchEvent(new Event('input', { bubbles: true })); }
        const pointCardsInput = [...newGroup.querySelectorAll('label')].find(l => l.textContent.includes('é›†é»å¡å…Œæ›æ•¸é‡'))?.querySelector('input');
        if (pointCardsInput) { pointCardsInput.value = g.pointCards; pointCardsInput.dispatchEvent(new Event('input', { bubbles: true })); }
        const adjustmentInput = [...newGroup.querySelectorAll('label')].find(l => l.textContent.includes('é‡‘é¡èª¿æ•´'))?.querySelector('input');
        if (adjustmentInput) { adjustmentInput.value = g.adjustment; adjustmentInput.dispatchEvent(new Event('input', { bubbles: true })); }
        const selfContainerCheckbox = [...newGroup.querySelectorAll('label')].find(l => l.textContent.includes('è‡ªå‚™å®¹å™¨'))?.querySelector('input[type=checkbox]');
        if (selfContainerCheckbox) { selfContainerCheckbox.checked = !!g.selfContainer; selfContainerCheckbox.dispatchEvent(new Event('change', { bubbles: true })); }

        // åŒ¯å…¥è¨‚å–®
        const orderContainer = newGroup.querySelector('.orderContainer');
        const addOrderBtn = newGroup.querySelector('.rowLine .btn.add');
        while (orderContainer.querySelectorAll('.orderCard').length < g.orders.length) {
          addOrderBtn.click();
          await new Promise(r => setTimeout(r, 20));
        }
        const cards = orderContainer.querySelectorAll('.orderCard');
        cards.forEach((card, idx) => {
          const ord = g.orders[idx];
          const rowLines = card.querySelectorAll('.rowLine');
          if (rowLines[0]) {
            const sel = rowLines[0].querySelector('select');
            const num = rowLines[0].querySelector('input[type="number"]');
            if (sel) { sel.value = ord.item; sel.dispatchEvent(new Event('change', { bubbles: true })); }
            if (num) { num.value = ord.quantity; num.dispatchEvent(new Event('input', { bubbles: true })); }
          }
          if (rowLines[1]) {
            const sels = rowLines[1].querySelectorAll('select');
            if (sels[0]) { sels[0].value = ord.productA; sels[0].dispatchEvent(new Event('change', { bubbles: true })); }
            if (sels[1]) { sels[1].value = ord.productB; sels[1].dispatchEvent(new Event('change', { bubbles: true })); }
            ord.accessories.forEach((a, ai) => {
              if (sels[2 + ai]) { sels[2 + ai].value = a || ''; sels[2 + ai].dispatchEvent(new Event('change', { bubbles: true })); }
            });
          }
        });

        // æ›´æ–°æ‘˜è¦èˆ‡ä»»å‹™åˆ—è¡¨
        // æ¢å¾©åŸå§‹é¡§å®¢ä¾†æºæ™‚é–“
        if (g.customerSourceTime) newGroup.dataset.customerSourceTime = g.customerSourceTime;
        // é‡æ–°è§¸ç™¼ç‹€æ…‹é¸å–®ä»¥åˆå§‹åŒ–å‡çµè¦–çª—
        const statusSel2 = newGroup.querySelector('.groupHeader > select');
        if (statusSel2) statusSel2.dispatchEvent(new Event('change', { bubbles: true }));
        if (typeof updateAllDailySummary === 'function') updateAllDailySummary();
        if (typeof updateTaskLists === 'function') updateTaskLists();
      }

      alert('åŒ¯å…¥å®Œæˆï¼Œè«‹äººå·¥ç¢ºèªæ™‚é–“/ç‹€æ…‹ç­‰ç´°ç¯€');
    });
    input.click();
  }



  // ç¶å®šæŒ‰éˆ•
  const exportBtn = document.getElementById('exportTxtBtn');
  if (exportBtn) exportBtn.replaceWith(exportBtn.cloneNode(true));
  const newExportBtn = document.getElementById('exportTxtBtn');
  if (newExportBtn) newExportBtn.addEventListener('click', exportToTxt);

  const importBtn = document.getElementById('importTxtBtn');
  if (importBtn) importBtn.replaceWith(importBtn.cloneNode(true));
  const newImportBtn = document.getElementById('importTxtBtn');
  if (newImportBtn) newImportBtn.addEventListener('click', importFromTxt);
});
</script>



<script>
(function(){
  function parseCustomerSourceTime(str){
    if(!str) return null;
    const parts = str.split(':').map(n=>parseInt(n,10));
    if(parts.length<3 || parts.some(isNaN)) return null;
    const d=new Date();
    d.setHours(parts[0], parts[1], parts[2], 0);
    return d;
  }
  function updateTaskLists(){
    const now=new Date();
    const makeContainer=document.getElementById('makeTasks');
    const pickupContainer=document.getElementById('pickupTasks');
    if(!makeContainer || !pickupContainer) return;
    // preserve existing overtime-alert entries so rebuild doesn't remove their highlight
    const prevOvertime = [];
    Array.from(makeContainer.children).forEach(c=>{
      if(c.classList.contains('overtime-alert')){
        prevOvertime.push(c.textContent.trim());
      }
    });
    makeContainer.innerHTML='';
    pickupContainer.innerHTML='';
    const groups=[...document.querySelectorAll('.groupCard')];
    const makeStatuses=['æœªçµå¾…è£½','å·²çµå¾…è£½'];
    const pickupStatuses=['æœªçµå¾…å–','å·²çµå¾…å–'];
    function buildList(statusList, container){
      const items=groups
        .filter(g=>{
          const sel=g.querySelector('.groupHeader > select');
          return sel && statusList.includes(sel.value);
        })
        .map(g=>{
          const customerSourceTime=g.dataset.customerSourceTime||'';
          const sourceSelect=[...g.querySelectorAll('.rowLine select')].find(s=>[...s.options].some(o=>o.textContent==='é¡§å®¢ä¾†æº'));
          const customerSource=sourceSelect?.value||'';
          const pickupSpan=g.querySelector('.pickupText');
          const deliverySpan=g.querySelector('.deliveryText');
          let calendarText='';
          if (deliverySpan && deliverySpan.style.display !== 'none') {
            calendarText = deliverySpan.textContent;
          } else if (pickupSpan && pickupSpan.style.display !== 'none') {
            calendarText = pickupSpan.textContent;
          }
          const datetimeInput=g.querySelector('input[type="datetime-local"]');
          let calendarDate=null;
          if(datetimeInput && datetimeInput.value){
            calendarDate=new Date(datetimeInput.value);
          }
          const prod= typeof computeProductionTime === 'function' ? computeProductionTime(g) : {hours:0,minutes:0};
          const productionMs=((prod.hours*60)+prod.minutes)*60000;
          let isUrgent=false;
          if(calendarDate){
            const startBy=new Date(calendarDate.getTime() - productionMs);
            if(now >= startBy) isUrgent=true;
          }
          const customerSourceDate=parseCustomerSourceTime(customerSourceTime);
          return {
            group:g,
            status:g.querySelector('.groupHeader>select')?.value||'',
            customerSource: customerSource,
            customerSourceTime,
            customerSourceDate,
            calendarDate,
            calendarText,
            summary: window.getSummaryText ? getSummaryText(g) : '',
            isUrgent
          };
        });
      items.sort((a,b)=>{
        const groupA = a.calendarDate ? (a.isUrgent?0:1):2;
        const groupB = b.calendarDate ? (b.isUrgent?0:1):2;
        if(groupA!==groupB) return groupA - groupB;
        if(groupA===0 || groupA===1){
          if(a.calendarDate && b.calendarDate){
            if(a.calendarDate.getTime() !== b.calendarDate.getTime()){
              return a.calendarDate - b.calendarDate;
            }
          }
        } else {
          if(a.customerSourceDate && b.customerSourceDate){
            return a.customerSourceDate - b.customerSourceDate;
          } else if(a.customerSourceDate) return -1;
          else if(b.customerSourceDate) return 1;
        }
        return 0;
      });
      for(const it of items){
        const g=it.group;
        const entry=document.createElement('div');
        entry.style.padding='4px';
        entry.style.borderBottom='1px solid #ddd';
        entry.style.cursor='pointer';
        entry.style.display='flex';
        entry.style.alignItems='center';
        entry.style.gap='12px';
        const time=it.customerSourceTime || '';
        const customerSource=it.customerSource || '';
        const calendarText=it.calendarText || '';
        const summary=it.summary || '';
        const groupName = g.querySelector('.groupHeader h3')?.textContent.trim() || '';

        // info wrapperï¼šç¬¬ä¸€è¡Œç¾¤çµ„åç¨±ã€ç¬¬äºŒè¡Œæ˜¯æ™‚é–“ã€ä¾†æºã€ç‹€æ…‹åˆä½µ
        const info = document.createElement('div');
        info.style.display='flex';
        info.style.flexDirection='column';
        info.style.fontSize='12px';
        info.style.lineHeight='1.1';

        const nameDiv = document.createElement('div');
        nameDiv.textContent = groupName;
        nameDiv.style.fontWeight='bold';
        info.appendChild(nameDiv);

        if (time || customerSource || calendarText) {
          const secondLine = document.createElement('div');
          let combined = '';
          if (time) combined += time;
          if (customerSource) {
            if (combined) combined += ' ';
            combined += customerSource;
          }
          if (calendarText) {
            if (combined) combined += ' ';
            combined += calendarText;
          }
          secondLine.textContent = combined;
          info.appendChild(secondLine);
        }

        const summaryDiv = document.createElement('div');
        summaryDiv.textContent = summary;
        summaryDiv.style.fontSize='2.5rem';
        summaryDiv.style.fontWeight='700';
        summaryDiv.style.whiteSpace='nowrap';

        entry.appendChild(info);
        entry.appendChild(summaryDiv);
        if (it.status && it.status.includes('æœªçµ')) {
          entry.style.color = '#8B0000';
        }
        entry.addEventListener('click', ()=>{
          g.scrollIntoView({behavior:'smooth', block:'center'});
        });
        container.appendChild(entry);
      }
    }
    buildList(makeStatuses, makeContainer);
    buildList(pickupStatuses, pickupContainer);
    // restore overdue highlights that existed before the rebuild
    if (typeof prevOvertime !== 'undefined' && prevOvertime.length) {
      Array.from(makeContainer.children).forEach(c => {
        prevOvertime.forEach(prev => {
          if (prev && (c.textContent.includes(prev) || prev.includes(c.textContent))) {
            c.classList.add('overtime-alert');
          }
        });
      });
    }
  }  window.updateTaskLists = updateTaskLists;


  function setupListeners(){
    document.querySelectorAll('.groupCard').forEach(g=>{
      const sel=g.querySelector('.groupHeader > select');
      if(sel && !sel.dataset._taskBound){
        sel.addEventListener('change', ()=>{ updateTaskLists(); });
        sel.dataset._taskBound='1';
      }
      const datetimeInput=g.querySelector('input[type="datetime-local"]');
      if(datetimeInput && !datetimeInput.dataset._taskBound){
        datetimeInput.addEventListener('change', ()=>{ updateTaskLists(); });
        datetimeInput.dataset._taskBound='1';
      }
      g.querySelectorAll('.rowLine select, .rowLine input[type="number"], .rowLine input[type="text"]').forEach(el=>{
        if(!el.dataset._taskBound){
          if(el.tagName && el.tagName.toLowerCase()==='select'){
            el.addEventListener('change', ()=>{ updateTaskLists(); });
          } else {
            el.addEventListener('input', ()=>{ updateTaskLists(); });
          }
          el.dataset._taskBound='1';
        }
      });
    });
  }

  // hook into existing summary update loop
  const origUpdateAllDailySummary = window.updateAllDailySummary;
  window.updateAllDailySummary = function(){
    if(typeof origUpdateAllDailySummary === 'function') origUpdateAllDailySummary();
    setupListeners();
    updateTaskLists();
  };
  // also call on load
  document.addEventListener('DOMContentLoaded', ()=>{
    setupListeners();
    setTimeout(updateTaskLists,500);
  });
})();
</script>


<script>
// broader delegation to ensure any change inside a groupCard triggers task list refresh
document.body.addEventListener('input', e => {
  if (e.target.closest && e.target.closest('.groupCard')) updateTaskLists();
}, true);
document.body.addEventListener('change', e => {
  if (e.target.closest && e.target.closest('.groupCard')) updateTaskLists();
}, true);
</script>


<script>
// å¼·åˆ¶æŒ‡å®šç¾¤çµ„å®¹å™¨ï¼Œä¿®æ­£ sticky å¤±æ•ˆå•é¡Œ
window.findGroupContainer = function() {
  const container = document.getElementById('groupsContainer');
  if (container) return container;
  const existing = document.querySelector('.groupCard');
  if (existing && existing.parentElement) return existing.parentElement;
  const sticky = document.querySelector('.stickyBar');
  if (sticky) {
    let next = sticky.nextElementSibling;
    while (next) {
      if (next.tagName && next.tagName.toLowerCase() === 'div') return next;
      next = next.nextElementSibling;
    }
  }
  return document.body;
};
</script>
</body>
</html>
