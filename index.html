<!DOCTYPE html>

<html lang="zh-TW">
<head>
<meta charset="utf-8"/>
<title>訂單系統 V1.01.36</title>
<style>
    * { box-sizing: border-box; }
    body { font-family: sans-serif; padding: 20px; margin: 0; }

    select, input[type="text"], input[type="number"], input[type="datetime-local"] {
      font-size: 14px;
      padding: 6px 10px;
      margin: 4px 6px 10px 0;
    }

    .invalid { background-color: #ffe4e1 !important; }

    .btn {
      padding: 6px 12px;
      margin-right: 8px;
      cursor: pointer;
      border: 1px solid #bbb;
      background: #f2f2f2;
      font-size: 14px;
    }

    .btn.add { background: #e1f5fe; border-color: #81d4fa; }
    .btn.del { background: #ffcdd2; border-color: #e57373; }
    .btn.copy { background: #fff9c4; border-color: #fdd835; }

    .stickyBar {
      position: sticky;
      top: 0;
      background: white;
      padding: 10px 0;
      z-index: 100;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .groupCard {
      border: 2px dashed #aaa;
      padding: 12px;
      margin-bottom: 24px;
    }

    .groupHeader {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .orderContainer {
      display: flex;
      flex-wrap: nowrap;
      overflow-x: auto;
      gap: 16px;
      padding-bottom: 8px;
      margin-bottom: 10px;
    }

    .orderCard {
      flex: 0 0 auto;
      width: 250px;
      border: 1px solid #999;
      padding: 10px;
      background: #fcfcfc;
    }

    .orderTitle {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      margin-bottom: 6px;
    }

    .orderFields > div {
      margin-bottom: 6px;
    }

    .extraGrid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .summaryWrapper {
  font-size: 13px;
  white-space: pre-line;
  border-left: 4px solid #ccc;
  background: #f5f5f5;
  padding: 6px 10px;
  flex: 1;
  max-width: 100%;
  display: flex;
  flex-direction: column;
}

.summaryText {
  font-size: 13px;
  white-space: pre-line;
  padding-bottom: 4px;
}
      font-size: 13px;
      white-space: pre-line;
      border-left: 4px solid #ccc;
      background: #f5f5f5;
      padding: 6px 10px;
      flex: 1;
      max-width: 100%;
    }

    .rowLine {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    #logoutBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #eee;
      border: 1px solid #aaa;
      padding: 4px 8px;
      font-size: 13px;
      cursor: pointer;
      z-index: 9999;
    }
  
#logoutBtn { position: fixed; top: 10px; right: 10px; background: #eee; border: 1px solid #aaa; padding: 4px 8px; font-size: 13px; cursor: pointer; z-index: 9999; }

.orderLabel.defaultRed {
  color: #b22222;
}


    #dailyTotalsBar {
      background: white;
      padding: 6px 0; margin-top:4px;
      z-index: 101;
      border-bottom: 1px solid #ccc;
      display: flex; flex-basis: 100%; width:100%;
      gap: 12px;
      flex-wrap: wrap;
      font-size: 13px;
      align-items: center;
      margin-left: 10px;
    }

/* 倒數鬧鐘樣式 */
.countdown-wrapper {
  display: inline-flex;
  gap: 6px;
  align-items: center;
  margin-left: 8px;
  flex-wrap: nowrap;
  font-size: 250%;
}
.countdown-display {
  min-width: 60px;
  font-family: monospace;
  background: #222;
  color: #fff;
  padding: 4px 8px;
  border-radius: 4px;
  text-align: center;
}
.countdown-btn {
  padding: 4px 8px;
  font-size:  12px;
  cursor: pointer;
  border: 1px solid #888;
  border-radius: 3px;
  background: #f2f2f2;
}
.overtime-alert {
  animation: shake 0.6s ease-in-out infinite;
  filter: invert(100%);
  color: yellow !important;
}
@keyframes shake {
  0%,100% { transform: translateX(0); }
  20% { transform: translateX(-3px); }
  40% { transform: translateX(3px); }
  60% { transform: translateX(-2px); }
  80% { transform: translateX(2px); }
}
.task-countdown {
  margin-left: 6px;
  font-weight: bold;
  background: #222;
  color: #fff;
  padding: 2px 6px;
  border-radius: 4px;
  font-size:   150%;
}
/* fallback highlight（如果找不到對應 makeTask 元素時用） */
.makeTask-fallback {
  background: #ffe8e8;
  border: 1px solid #d33;
  padding: 4px;
  margin-bottom: 2px;
}


#makeTasks { font-size: initial; }
#pickupTasks { font-size: 250%; }
</style>
</head>
<body>



<div id="topStickyWrapper" style="position:sticky; top:0; z-index:220; display:flex; flex-direction:column; background:white; border-bottom:1px solid #ccc; padding:8px;">
  <div id="taskListsWrapper" style="display:flex; gap:12px; margin-bottom:6px;">
    <div style="flex:1; height:20vh; border:1px solid #bbb; padding:6px; display:flex; flex-direction:column;">
      <div style="font-weight:bold; margin-bottom:4px;">待製任務列表</div>
      <div id="makeTasks" style="display:flex; flex-direction:column; gap:4px; overflow:auto; flex:1;"></div>
    </div>
    <div style="flex:1; height:20vh; border:1px solid #bbb; padding:6px; display:flex; flex-direction:column;">
      <div style="font-weight:bold; margin-bottom:4px;">待取任務列表</div>
      <div id="pickupTasks" style="display:flex; flex-direction:column; gap:4px; overflow:auto; flex:1;"></div>
    </div>
  </div>
  <div class="stickyBar">
<h2>訂單系統 V1.01.36</h2>
<button class="btn add">➕ 新增客人</button><button class="btn" id="exportTxtBtn">📤 匯出TXT</button><button class="btn" id="importTxtBtn">📥 匯入TXT</button>
<label>烤盤計時：
        <input style="width: 100px;" type="number" value="4"/>分
        <input style="width: 100px;" type="number" value="30"/>秒；
    </label>
<label>顆秒：
        <input style="width: 100px;" type="number" value="20"/>；
    </label>
<label>滿
        <input style="width: 100px;" type="number" value="12"/> 份折
        <input style="width: 100px;" type="number" value="1"/> 份；
    </label>
<label>滿
        <input style="width: 100px;" type="number" value="60"/> 元
        <input style="width: 100px;" type="number" value="1"/> 點；
    </label>
<label>滿
        <input style="width: 100px;" type="number" value="6"/> 份乘
        <input style="width: 100px;" type="number" value="2"/> 倍；
    </label>
<label>點卡折抵上限：
        <input style="width: 100px;" type="number" value="35"/> 元
    </label>
    
</div>
  <div id="dailyTotalsBar" style="margin-bottom:5px;">
      <div id="dailyTotals" style="display:inline-block; margin-right:10px;"></div>
      <div id="paymentBreakdown" style="display:inline-block;"></div>
  </div>
</div>
</div>

<div>
<div id="groupsContainer">
<div class="groupCard">
<div class="groupHeader">
<div class="groupHeader">
<button class="btn del">❌</button>
<h3>第 1 組客人</h3>
</div>
<select>
<option>已出貨</option>
<option>已結待製</option>
<option selected="">未結待製</option>
<option>已結待取</option>
<option>未結待取</option>
<option>取消訂單</option>
</select>

<div class="summaryWrapper">
<div class="summaryText"></div>
<div class="summaryBoxText"></div>
</div>
</div>
<div class="rowLine"><button class="btn add">➕ 新增訂單</button>
<select>
<option value="">顧客來源</option>
<option>到店</option><option>電話</option><option>LINE</option>
<option>FB</option><option>IG</option><option>簡訊</option>
<option>Ｕber Eats</option>
</select>
<select><option value="">支付方式</option></select>
<label>註記：<input placeholder="註記" type="text"/></label>
<input type="datetime-local"/><span class="pickupText" style="margin-left:6px; display:none;"></span>
<label>外送資訊：<input placeholder="外送資訊" type="text"/></label><span class="deliveryText" style="margin-left:6px; display:none;"></span>
<label>集點卡兌換數量：<input type="number" value="0"/></label>
<label>金額調整：<input class="adjustInput" type="number"/></label>
<label><input type="checkbox"/> 自備容器</label>
</div>

<div class="orderContainer">
<!-- 靜態產生 6 組訂單 -->
<div class="orderCard">
<div class="orderTitle">
<span></span>
<span class="costText"></span>
<button class="btn del">❌</button>
</div>
<div class="rowLine">
<select style="width: 100px;"><option value="">品項</option></select>
<input min="1" style="width: 100px;" type="number" value="1"/>
</div>
<div class="rowLine">
<select style="width: 100px;"><option value="">商品A</option></select>
<select style="width: 100px;"><option value="">商品B</option></select>
<select style="width: 62px;"><option value="">附</option></select>
<select style="width: 62px;"><option value="">附</option></select>
<select style="width: 62px;"><option value="">附</option></select>
<select style="width: 62px;"><option value="">附</option></select>
<select style="width: 62px;"><option value="">附</option></select>
<select style="width: 62px;"><option value="">附</option></select>
</div>
</div>
</div>
</div>
</div>
</div>
<button id="logoutBtn" style="position: fixed; top: 10px; right: 10px; background: #eee; border: 1px solid #aaa; padding: 4px 8px; font-size: 13px; cursor: pointer; z-index: 9999;">🔓 登出金鑰</button>
<script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
<script>
(() => {
  const FILE_URL = "https://raw.githubusercontent.com/menghushao/Order-management-product/main/gridData.json";
  const STORAGE_KEY = "gh_token";

  function logout() {
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
  }

  async function fetchGridData() {
    const res = await fetch(FILE_URL);
    return await res.json();
  }

  function decryptGrid(token, ciphertext, ivHex) {
    const key = CryptoJS.enc.Utf8.parse(token.slice(0, 32).padEnd(32, '0'));
    const iv = CryptoJS.enc.Hex.parse(ivHex);
    const encrypted = CryptoJS.enc.Base64.parse(ciphertext);
    const decrypted = CryptoJS.AES.decrypt({ ciphertext: encrypted }, key, {
      iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7
    });
    const json = decrypted.toString(CryptoJS.enc.Utf8);
    return JSON.parse(json);
  }

  async function ensureToken() {
    const cached = JSON.parse(localStorage.getItem(STORAGE_KEY) || "null");
    const now = Date.now();
    if (cached && now < cached.expires) return cached.token;

    let token;
    while (!token) {
      token = prompt("請輸入 GitHub Token：");
      if (!token) alert("必須輸入 token 才能使用系統！");
    }

    const expires = now + 7 * 24 * 60 * 60 * 1000;
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ token, expires }));
    return token;
  }

  async function init() {
    const token = await ensureToken();
    let rawData;

    try {
      rawData = await fetchGridData();
    } catch (fetchErr) {
      console.warn("⚠️ 警告：fetch 似乎失敗，但可能成功（local file CORS 誤報）", fetchErr);
    }

    if (!rawData || !rawData.ciphertext || !rawData.iv) {
      alert("⚠️ 無法取得正確資料格式，請確認 gridData.json 是否包含 ciphertext 與 iv");
      logout();
      return;
    }

    try {
      const decrypted = decryptGrid(token, rawData.ciphertext, rawData.iv);
      window.gridData = decrypted;
      // ✅ 產生支付方式選單
      const paymentOptions = [
        ...new Set(decrypted[6].slice(15, 30).filter(Boolean)) // P~AD = index 15~29
      ];
      window.populatePaymentOptions = function(container = document) {
        container.querySelectorAll('select').forEach(sel => {
          if (sel.options[0]?.textContent === '支付方式') {
            sel.innerHTML = '<option value="">支付方式</option>' +
              paymentOptions.map(opt => `<option>${opt}</option>`).join('');
          }
        });
      };
      window.populatePaymentOptions();

      document.querySelectorAll('select').forEach(sel => {
        if (sel.options[0]?.textContent === '支付方式') {
          sel.innerHTML = '<option value="">支付方式</option>' +
            paymentOptions.map(opt => `<option>${opt}</option>`).join('');
        }
      });

  initGridDataCache();

      window.updateAccessoryOptions = function(card) {
        const decrypted = window.gridData;
        const selects = card.querySelectorAll('select');
        const productA = selects[1]?.value;
        const productB = selects[2]?.value;
        const finalProduct = productB || productA;
        if (!finalProduct) return;

        const matchedRow = decrypted.slice(10, 105).find(row => row[1] === finalProduct);
        if (!matchedRow) return;

        const options = matchedRow.slice(5, 15).filter(Boolean);
        const uniqueOptions = [...new Set(options)];

        selects.forEach(s => {
          if (s.options[0] && s.options[0].textContent === '附') {
            s.innerHTML = '<option value="">附</option>' +
              uniqueOptions.map(x => `<option>${x}</option>`).join('');
          }
        });
      }

      document.querySelectorAll('.orderCard').forEach(card => {
        const selects = card.querySelectorAll('select');
        selects.forEach(s => {
          if (s.options[0] && (s.options[0].textContent === '商品A' || s.options[0].textContent === '商品B')) {
            s.addEventListener('change', () => updateAccessoryOptions(card));
          }
        });
      });

      console.log("✅ 解密成功", decrypted);

/*
  🔍 decrypted 為一個二維陣列（Array of Arrays），對應原始 Excel 資料範圍：
     - 橫向欄位：A ~ AX（共 50 欄）
     - 縱向列數：1 ~ 106（共 106 列）
  例：decrypted[0][0] 對應 A1，decrypted[10][1] 對應 B11
*/

      window.bindItemSelectLogic = function(container = document) {
        const decrypted = window.gridData;
        container.querySelectorAll('select').forEach(sel => {
          if (sel.options[0] && sel.options[0].textContent === '品項') {
            sel.innerHTML = '<option value="">品項</option>' +
              [...new Set(decrypted.slice(10, 105).map(row => row[0]).filter(Boolean))]
              .map(x => `<option>${x}</option>`).join('');

            sel.addEventListener('change', e => {
              const selected = e.target.value;
              const card = e.target.closest('.orderCard');
              if (!selected || !card) return;

              const matched = decrypted.slice(10, 105)
                .filter(row => row[0] === selected)
                .map(row => row[1])
                .filter(Boolean);

              const unique = [...new Set(matched)];

              card.querySelectorAll('select').forEach(s => {
                if (
                  s.options[0] &&
                  (s.options[0].textContent === '商品A' || s.options[0].textContent === '商品B')
                ) {
                  s.innerHTML = '<option value="">' + s.options[0].textContent + '</option>' +
                    unique.map(x => `<option>${x}</option>`).join('');
                }
              });
            });
          }
        
          if (sel.options[0] && (sel.options[0].textContent === '商品A' || sel.options[0].textContent === '商品B')) {
            sel.addEventListener('change', e => {
              const card = e.target.closest('.orderCard');
              if (card) {
  window.updateAccessoryOptions(card);
  



function getItemPortionSummary(groupCard) {
  if (!window.gridData) return '';
  const rows = window.gridData.slice(10, 105);
  const ahOrder = rows.map(r => r[33]).filter(Boolean);
  const itemOrderMap = new Map(ahOrder.map((name, idx) => [name, idx]));

  const portionMap = new Map();
  const cards = [...groupCard.querySelectorAll('.orderCard')];

  for (const card of cards) {
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || '1');
    const a = selects[1]?.value;
    const b = selects[2]?.value;

    if (!a && !b) continue;

    const record = (val, q) => {
      const row = rows.find(r => r[1] === val); // B欄比對
      if (!row) return;
      const item = row[0]; // A欄品項
      const perPortion = parseFloat(row[30]); // AE欄
      if (!item || !perPortion || isNaN(perPortion)) return;
      if (!portionMap.has(item)) portionMap.set(item, { total: 0, perPortion });
      portionMap.get(item).total += q;
    };

    if (a && !b) record(a, qty);
    else if (!a && b) record(b, qty * 2);
    else {
      record(a, qty);
      record(b, qty);
    }
  }

  const result = [...portionMap.entries()]
    .sort((a, b) => (itemOrderMap.get(a[0]) ?? Infinity) - (itemOrderMap.get(b[0]) ?? Infinity))
    .map(([item, { total, perPortion }]) => {
      const intPart = Math.floor(total / perPortion);
      const remainder = total % perPortion;
      return `${item}${intPart}份${remainder ? '(不足份)' : ''}`;
    });

  return result.join('；');
}



// 🔄 更新 bindSummaryUpdater 以同時處理 summaryText 與 summaryBoxText








let rows = [], rowsMap = new Map(), ahOrder = [];

function initGridDataCache() {
  if (!window.gridData) return;
  rows = window.gridData.slice(10, 105);
  ahOrder = rows.map(r => r[33]);
  rowsMap = new Map(rows.map(r => [r[1], { short: r[2], type: r[0] }]));
}


function summarizeChunk(cards) {
  const map = new Map();
  for (const card of cards) {
    const s = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || 1);
    const a = s[1]?.value, b = s[2]?.value;
    const acc = [];
    for (let i = 3; i < 9; i++) {
      const v = s[i]?.value;
      if (v) acc.push(v);
    }

    const ra = rowsMap.get(a), rb = rowsMap.get(b);
    const sa = ra?.short || '', sb = rb?.short || '';
    const type = ra?.type || rb?.type || '';

    if (!sa && !sb) continue;
    const name = sa && sb ? [sa, sb].sort().join('+') : sa || `${sb}+${sb}`;
    const full = acc.length ? `${name}(${acc.join('+')})` : name;

    if (!map.has(full)) map.set(full, { count: 0, type, idx: map.size });
    map.get(full).count += qty;
  }

  return [...map.entries()]
    .sort((a, b) => ahOrder.indexOf(a[1].type) - ahOrder.indexOf(b[1].type) || a[1].idx - b[1].idx)
    .map(([k, v]) => `${k}X${v.count}`);
}

function getBoxSummaryText(groupCard) {
  if (!window.gridData) return '';
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const chunks = [];
  let chunk = [], splitCount = 0;

  for (const card of orderCards) {
    const hasValue = [...card.querySelectorAll('select')].some(s => s.value);
    if (hasValue) {
      chunk.push(card);
    } else {
      if (chunk.length) chunks.push(chunk);
      chunk = [];
      splitCount++;
    }
  }
  if (chunk.length) chunks.push(chunk);
  if (chunks.length <= 1 || splitCount === 0) return '';

  return chunks.map(cards => '【' + summarizeChunk(cards).join('；') + '】').join('');
}

function getSummaryText(groupCard) {
  if (!window.gridData) return '';
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  return summarizeChunk(orderCards).join('；');
}



window.checkOrderColor(card);
}
            });
          }});
      };

      // 頁面一開始綁定一次
      window.bindItemSelectLogic();

      // 綁定品項選單的 onchange 事件，更新商品A/B
      document.querySelectorAll('select').forEach(sel => {
        if (sel.options[0] && sel.options[0].textContent === '品項') {
          sel.addEventListener('change', e => {
            const selected = e.target.value;
            const card = e.target.closest('.orderCard');
            if (!selected || !card) return;

            const matched = decrypted.slice(10, 105)
              .filter(row => row[0] === selected)
              .map(row => row[1])
              .filter(Boolean);

            const unique = [...new Set(matched)];

            card.querySelectorAll('select').forEach(s => {
              if (
                s.options[0] &&
                (s.options[0].textContent === '商品A' || s.options[0].textContent === '商品B')
              ) {
                s.innerHTML = '<option value="">'+ s.options[0].textContent + '</option>' +
                  unique.map(x => `<option>${x}</option>`).join('');
              }
            });
          });
        }
      });

      const allItems = decrypted.slice(10, 105).map(row => row[0]).filter(Boolean);
      const uniqueItems = [...new Set(allItems)];

      document.querySelectorAll('select').forEach(sel => {
        if (sel.options[0] && sel.options[0].textContent === '品項') {
          sel.innerHTML = '<option value="">品項</option>' +
            uniqueItems.map(x => `<option>${x}</option>`).join('');
        }
      });

    } catch (err) {
      alert("登入失敗或解密錯誤，請重新登入。\n\n錯誤訊息：" + err.message);
      logout();
    }
  }

  
window.findGroupContainer = function() {
  const existing = document.querySelector(".groupCard");
  if (existing && existing.parentElement) return existing.parentElement;
  const sticky = document.querySelector('.stickyBar');
  if (sticky) {
    let next = sticky.nextElementSibling;
    while (next) {
      if (next.tagName && next.tagName.toLowerCase() === 'div') return next;
      next = next.nextElementSibling;
    }
  }
  return document.body;
};
document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("logoutBtn");
    if (btn) {
      btn.addEventListener("click", () => {
        console.log("🔓 使用者點擊登出金鑰");
        logout();
      });
    }
    init();
  });
})();
</script>
<script>
document.addEventListener("DOMContentLoaded", () => {
  const original = document.querySelector(".groupCard");
  const groupTemplate = original.cloneNode(true);
  window.groupTemplate = groupTemplate;
const addBtn = document.querySelector(".stickyBar .btn.add");

  if (addBtn && !addBtn.classList.contains("bound")) {
    addBtn.classList.add("bound");

    addBtn.addEventListener("click", () => {
      let container = original?.parentElement; if (!container) container = window.findGroupContainer();
      const clone = groupTemplate.cloneNode(true);

      const count = container.querySelectorAll(".groupCard").length + 1;
      const h3 = clone.querySelector("h3");
      if (h3) h3.textContent = `第 ${count} 組客人`;

      container.appendChild(clone);

      initGroup(clone);
      window.bindItemSelectLogic(clone);
      bindSummaryUpdater(clone);
      bindCopyButton(clone);
      if (window.populatePaymentOptions) window.populatePaymentOptions(clone);
    });
  }

  // 初始化每組 groupCard 的行為
  
// 倒數鬧鐘功能 - helper functions
function formatTime(sec) {
  const sign = sec < 0 ? '-' : '';
  const abs = Math.abs(Math.floor(sec));
  const m = Math.floor(abs / 60).toString().padStart(2, '0');
  const s = (abs % 60).toString().padStart(2, '0');
  return sign + m + ':' + s;
}

function ensureCountdownControl(group) {
  if (group.__hasCountdown) return;
  group.__hasCountdown = true;

  const containerLabel = [...group.querySelectorAll('label')].find(l => l.textContent.includes('自備容器'));
  const statusSelect = group.querySelector('.groupHeader > select');
  if (statusSelect) {
    statusSelect.addEventListener('change', () => {
      const val = statusSelect.value;
      if (targetTime && val !== '未結待製' && val !== '已結待製') {
        resetCountdown();
      }
    });
  }

  if (!containerLabel) return;

  const wrapper = document.createElement('div');
  wrapper.className = 'countdown-wrapper';
  wrapper.innerHTML = `
    <div class="countdown-display">00:00</div>
    <input type="number" class="countdown-duration" title="倒數秒數" style="width:70px;" min="1" value="270" placeholder="秒"/>
    <input type="text" class="countdown-audio" title="音效路徑" style="width:260px;" value="C:\\Users\\add00\\OneDrive\\桌面\\萌虎燒\\中華一番！ost+4.万里の長城.mp3" placeholder="音效 URL"/>
    <input type="number" class="countdown-audio-duration" title="播放秒數" style="width:70px;" min="1" value="15" placeholder="播放秒"/>
    <button class="countdown-start countdown-btn">啟動</button>
    <button class="countdown-stop countdown-btn" disabled>停止</button>
    <button class="countdown-reset countdown-btn">重置</button>
  `;
  containerLabel.parentElement.appendChild(wrapper);

  const display = wrapper.querySelector('.countdown-display');
  const durationInput = wrapper.querySelector('.countdown-duration');
  const audioInput = wrapper.querySelector('.countdown-audio');
  const audioDurInput = wrapper.querySelector('.countdown-audio-duration');
  const startBtn = wrapper.querySelector('.countdown-start');
  const stopBtn = wrapper.querySelector('.countdown-stop');
  const resetBtn = wrapper.querySelector('.countdown-reset');

  let targetTime = null;
  let remaining = parseInt(durationInput.value,10) || 270;
  let timerId = null;
  let alerted = false;
  let audio = new Audio();
  let audioTimeout = null;

  function updateDisplay() {
    if (!targetTime) {
      display.textContent = formatTime(remaining);
      return;
    }
    const now = Date.now();
    const diff = Math.round((targetTime - now)/1000);
    display.textContent = formatTime(diff);
    if (diff < 0 && !alerted) {
      alerted = true;
      triggerAlert();
    }
  }

  function tick() { updateDisplay(); }

  
  function startCountdown() {

    const statusSelect = group.querySelector('.groupHeader > select');
    const status = statusSelect?.value;
    if (status !== '未結待製' && status !== '已結待製') {
      alert('只有「未結待製」或「已結待製」狀態才能啟動倒數');
      return;
    }
    // 使用現存 remaining 當作要繼續的時間（停止之後 resume），reset 會重新設定 remaining
    if (remaining == null || isNaN(remaining)) {
      const dur = parseInt(durationInput.value, 10);
      remaining = isNaN(dur) || dur <= 0 ? 270 : dur;
    }
    const now = Date.now();
    targetTime = now + remaining * 1000;
    // 如果已經顯示過 alert（已超時）就保留 alerted 狀態，否則保持原樣
    startBtn.disabled = true;
    stopBtn.disabled = false;
    if (timerId) clearInterval(timerId);
    timerId = setInterval(tick, 250);
    updateDisplay();
  }


  function stopCountdown() {
    if (timerId) clearInterval(timerId);
    if (targetTime) {
      const now = Date.now();
      remaining = Math.round((targetTime - now)/1000);
    }
    targetTime = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    updateDisplay();
  }

  function resetCountdown() {
    if (timerId) clearInterval(timerId);
    const dur = parseInt(durationInput.value,10);
    remaining = isNaN(dur) || dur <= 0 ? 270 : dur;
    targetTime = null;
    alerted = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    display.textContent = formatTime(remaining);
    clearAlertOnThisTask();
    display.style.fontWeight='normal';
  }

  function triggerAlert() {
    display.style.fontWeight='bold';
    highlightMakeTask();
    audio.src = audioInput.value;
    audio.play().catch(()=>{});
    const playDur = parseInt(audioDurInput.value,10);
    if (!isNaN(playDur) && playDur>0) {
      if (audioTimeout) clearTimeout(audioTimeout);
      audioTimeout = setTimeout(()=>{ audio.pause(); }, playDur*1000);
    }
  }

  function highlightMakeTask() {
    const makeContainer = document.getElementById('makeTasks');
    if (!makeContainer) return;
    const title = group.querySelector('h3')?.textContent || '';
    let itemDiv = Array.from(makeContainer.children).find(c => (c.textContent || '').includes(title));
    if (itemDiv) {
      itemDiv.classList.add('overtime-alert');
    } else {
      const placeholder = document.createElement('div');
      placeholder.textContent = `⚠️ ${title} 倒數超時（已超時）`;
      placeholder.className = 'overtime-alert makeTask-fallback';
      makeContainer.prepend(placeholder);
    }
  }
  function clearAlertOnThisTask() {
    const makeContainer = document.getElementById('makeTasks');
    if (!makeContainer) return;
    const title = group.querySelector('h3')?.textContent || '';
    let itemDiv = Array.from(makeContainer.children).find(c => (c.textContent || '').includes(title));
    if (itemDiv) {
      itemDiv.classList.remove('overtime-alert');
    }
    // 移除 fallback placeholder（若有的話）
    Array.from(makeContainer.querySelectorAll('.makeTask-fallback')).forEach(el => {
      if (el.textContent.includes(title)) {
        el.remove();
      }
    });
  }


  function clearAlertOnTask() {
    const makeContainer = document.getElementById('makeTasks');
    if (!makeContainer) return;
    Array.from(makeContainer.children).forEach(c => c.classList.remove('overtime-alert'));
  }

  startBtn.addEventListener('click', startCountdown);
  stopBtn.addEventListener('click', stopCountdown);
  resetBtn.addEventListener('click', resetCountdown);

  display.textContent = formatTime(remaining);
}



// 同步倒數時間到待製任務列表（待製任務列表右側 badge）
function syncCountdownsToMakeTasks() {
  const makeContainer = document.getElementById('makeTasks');
  if (!makeContainer) return;
  document.querySelectorAll('.groupCard').forEach(group => {
    if (!group.__hasCountdown) return;
    const display = group.querySelector('.countdown-display');
    if (!display) return;
    const countdownText = display.textContent;
    const groupName = group.querySelector('h3')?.textContent?.trim() || '';
    if (!groupName) return;
    const entry = Array.from(makeContainer.children).find(c => (c.textContent || '').includes(groupName));
    if (!entry) return;
    let badge = entry.querySelector('.task-countdown');
    if (!badge) {
      badge = document.createElement('span');
      badge.className = 'task-countdown';
      badge.style.marginLeft = '6px';
      badge.style.fontWeight = 'bold';
      badge.style.background = '#222';
      badge.style.color = '#fff';
      badge.style.padding = '2px 6px';
      badge.style.borderRadius = '4px';
      
      entry.prepend(badge);
    }
    badge.textContent = countdownText;
    if (countdownText.startsWith('-')) {
      badge.style.filter = 'invert(100%)';
    } else {
      badge.style.filter = '';
    }
  });
}
setInterval(syncCountdownsToMakeTasks, 500);

function initGroup(group) {
    // 客戶來源時間顯示（在訂單資訊內，選擇後顯示 hh:mm:ss）
    const sourceSelect = [...group.querySelectorAll(".rowLine select")].find(sel => [...sel.options].some(o => o.textContent === "顧客來源"));
    if (sourceSelect) {
      sourceSelect.addEventListener('change', () => {
        if (!sourceSelect.value) {
          delete group.dataset.customerSourceTime;
          if (typeof updateTaskLists === 'function') updateTaskLists();
          return;
        }
        const now = new Date();
        const hh = now.getHours().toString().padStart(2, '0');
        const mm = now.getMinutes().toString().padStart(2, '0');
        const ss = now.getSeconds().toString().padStart(2, '0');
        group.dataset.customerSourceTime = `${hh}:${mm}:${ss}`;
        if (typeof updateTaskLists === 'function') updateTaskLists();
      });
    }
// 萬年曆時間顯示（取餐 / 送達）
    function updateCalendarDisplay() {
      const datetimeInput = group.querySelector('input[type="datetime-local"]');
      const deliveryInput = [...group.querySelectorAll('label')].find(l => l.textContent.includes('外送資訊'))?.querySelector('input');
      const pickupSpan = group.querySelector('.pickupText');
      const deliverySpan = group.querySelector('.deliveryText');
      const dtVal = datetimeInput?.value;
      const deliveryVal = deliveryInput?.value;
      if (!dtVal) {
        if (pickupSpan) pickupSpan.style.display = 'none';
        if (deliverySpan) deliverySpan.style.display = 'none';
        return;
      }
      const dt = new Date(dtVal);
      const pad = n => n.toString().padStart(2, '0');
      const dateStr = `${dt.getFullYear()}/${pad(dt.getMonth()+1)}/${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}`;
      if (deliveryVal) {
        if (deliverySpan) {
          deliverySpan.textContent = `${dateStr}送達`;
          deliverySpan.style.display = '';
        }
        if (pickupSpan) pickupSpan.style.display = 'none';
      } else {
        if (pickupSpan) {
          pickupSpan.textContent = `${dateStr}取餐`;
          pickupSpan.style.display = '';
        }
        if (deliverySpan) deliverySpan.style.display = 'none';
      }
    }
    const datetimeInput = group.querySelector('input[type="datetime-local"]');
    const deliveryInput = [...group.querySelectorAll('label')].find(l => l.textContent.includes('外送資訊'))?.querySelector('input');
    if (datetimeInput) {
      datetimeInput.addEventListener('change', updateCalendarDisplay);
      datetimeInput.addEventListener('input', updateCalendarDisplay);
    }
    if (deliveryInput) {
      deliveryInput.addEventListener('input', updateCalendarDisplay);
      deliveryInput.addEventListener('change', updateCalendarDisplay);
    }

    const orderContainer = group.querySelector(".orderContainer");
    const addOrderBtn = group.querySelector(".rowLine .btn.add");
    let orderCount = orderContainer.children.length;
    let swapTarget = null;

    function clearSwapHighlight() {
      orderContainer.querySelectorAll(".btn.swap").forEach(btn => {
        btn.style.background = "#eee";
      });
    }

    function bindCardEvents(card) {
      const delBtn = card.querySelector(".btn.del");
      if (delBtn) {
        
delBtn.addEventListener("click", () => {
  if (confirm("確定要刪除這組訂單嗎？")) {
    const groupCard = card.closest('.groupCard');
    card.remove();
    if (groupCard) {
      if (window.bindSummaryUpdater) {
        window.bindSummaryUpdater(groupCard);
      }
      groupCard.querySelectorAll('.orderCard').forEach(window.checkOrderColor);
            if (typeof updateTaskLists === 'function') updateTaskLists();
    }
  }
});

      }

      const swapBtn = card.querySelector(".btn.swap");
      if (swapBtn) {
        swapBtn.addEventListener("click", () => {
          if (swapTarget === null) {
            swapTarget = card;
            clearSwapHighlight();
            swapBtn.style.background = "khaki";
          } else if (swapTarget === card) {
            swapTarget = null;
            clearSwapHighlight();
          } else {
          const selects1 = swapTarget.querySelectorAll('select');
          const selects2 = card.querySelectorAll('select');
          const inputs1 = swapTarget.querySelectorAll('input');
          const inputs2 = card.querySelectorAll('input');

          const values1 = [...selects1].map(s => s.value);
          const values2 = [...selects2].map(s => s.value);
          const inputsVal1 = [...inputs1].map(s => s.value);
          const inputsVal2 = [...inputs2].map(s => s.value);

          [...selects1].forEach((s, i) => {
            s.value = values2[i] || "";
            s.dispatchEvent(new Event('change', { bubbles: true }));
          });
          [...selects2].forEach((s, i) => {
            s.value = values1[i] || "";
            s.dispatchEvent(new Event('change', { bubbles: true }));
          });

          [...inputs1].forEach((s, i) => {
            s.value = inputsVal2[i] || "";
            s.dispatchEvent(new Event('input', { bubbles: true }));
          });
          [...inputs2].forEach((s, i) => {
            s.value = inputsVal1[i] || "";
            s.dispatchEvent(new Event('input', { bubbles: true }));
          });

          // ⬇️ 新增交換訂單標籤（orderLabel）文字
          const label1 = swapTarget.querySelector(".orderLabel");
          const label2 = card.querySelector(".orderLabel");
          if (label1 && label2) {
            const tmp = label1.textContent;
            label1.textContent = label2.textContent;
            label2.textContent = tmp;
          }

          swapTarget = null;

          swapTarget = null;
          clearSwapHighlight();
}
        });
      }
    }

    function createOrderCard(index) {
      const card = document.createElement("div");
      card.className = "orderCard";
      card.dataset.index = index;
      card.innerHTML = `
        <div class="orderTitle">
          <button class="btn swap" style="background:#eee;">⇄</button>
          <span class="orderLabel defaultRed">第 ${index + 1} 組訂單</span>
          <span class="costText"></span>
          <button class="btn del">❌</button>
        </div>
        <div class="rowLine">
          <select style="width: 100px;"><option value="">品項</option></select>
          <input type="number" min="1" value="1" style="width: 100px;">
        </div>
        <div class="rowLine">
          <select style="width: 100px;"><option value="">商品A</option></select>
          <select style="width: 100px;"><option value="">商品B</option></select>
          <select style="width: 62px;"><option value="">附</option></select>
          <select style="width: 62px;"><option value="">附</option></select>
          <select style="width: 62px;"><option value="">附</option></select>
          <select style="width: 62px;"><option value="">附</option></select>
          <select style="width: 62px;"><option value="">附</option></select>
          <select style="width: 62px;"><option value="">附</option></select>
        </div>
      `;
      bindCardEvents(card);
      checkOrderColor(card);
      window.bindItemSelectLogic(card); return card;
    }

    if (addOrderBtn) {
      addOrderBtn.addEventListener("click", () => {
        for (let i = 0; i < 5; i++) {
          const card = createOrderCard(orderCount);
          orderContainer.appendChild(card);
          orderCount++;
          bindSummaryUpdater(group);
        }
        orderContainer.scrollLeft = orderContainer.scrollWidth;
      });
    }

    // 初始化現有訂單（避免第一組不能交換）
    [...orderContainer.children].forEach((card, idx) => {
      if (!card.querySelector(".btn.swap")) {
        const titleDiv = card.querySelector(".orderTitle");
        const swapBtn = document.createElement("button");
        swapBtn.className = "btn swap";
        swapBtn.textContent = "⇄";
        swapBtn.style.background = "#eee";
        titleDiv.insertBefore(swapBtn, titleDiv.firstChild);
      }

      let label = card.querySelector(".orderLabel");
      if (!label) {
        label = document.createElement("span");
        label.className = "orderLabel";
        card.querySelector(".orderTitle").insertBefore(label, card.querySelector(".costText"));
      }
      label.textContent = `第 ${idx + 1} 組訂單`;

      bindCardEvents(card);
      checkOrderColor(card);
    });
  ensureCountdownControl(group);
  }

  // 初始化頁面第一組
  document.querySelectorAll(".groupCard").forEach(group => {
  if (window.populatePaymentOptions) window.populatePaymentOptions(group);
  initGroup(group);
  bindSummaryUpdater(group);
});
});

function getSummaryText(groupCard) {
  const decrypted = window.gridData;
  if (!decrypted) return '';

  const rows = decrypted.slice(10, 105);
  const ahOrder = rows.map(row => row[33]);
  const orderContainer = groupCard.querySelector('.orderContainer');
  const allOrders = [...orderContainer.querySelectorAll('.orderCard')];

  const summaryMap = new Map();

  for (const card of allOrders) {
    const selects = card.querySelectorAll('select');
    const qtyInput = card.querySelector('input[type="number"]');
    const qty = parseInt(qtyInput?.value || '1');

    const itemA = selects[1]?.value;
    const itemB = selects[2]?.value;
    const accessories = [...selects].slice(3, 9).map(s => s.value).filter(Boolean);

    let shortA = '', shortB = '', itemType = '';
    if (itemA) {
      const row = rows.find(r => r[1] === itemA);
      if (row) { shortA = row[2]; itemType = row[0]; }
    }
    if (itemB) {
      const row = rows.find(r => r[1] === itemB);
      if (row) { shortB = row[2]; if (!itemType) itemType = row[0]; }
    }

    if (!shortA && !shortB) continue;

    let baseName = '';
if (shortA && shortB) {
  const sortedNames = [shortA, shortB].sort();
  baseName = `${sortedNames[0]}+${sortedNames[1]}`;
} else if (shortB) {
  baseName = `${shortB}+${shortB}`;
} else if (shortA) {
  baseName = shortA;
}
const accessoriesStr = accessories.length ? `(${accessories.join('+')})` : '';
const fullName = `${baseName}${accessoriesStr}`;

    if (!summaryMap.has(fullName)) {
      summaryMap.set(fullName, { count: 0, type: itemType, index: summaryMap.size });
    }
    summaryMap.get(fullName).count += qty;
  }

  const sorted = [...summaryMap.entries()].sort((a, b) => {
    const typeA = a[1].type;
    const typeB = b[1].type;
    const idxA = ahOrder.indexOf(typeA);
    const idxB = ahOrder.indexOf(typeB);
    if (idxA !== idxB) return idxA - idxB;
    return a[1].index - b[1].index;
  });

  return sorted.map(([name, val]) => `${name}X${val.count}`).join('；');
}




function bindCopyButton(groupCard) {
  const btn = groupCard.querySelector('.groupHeader .btn.del');
  if (!btn) return;
  if (btn.dataset.copyBound) return;
  btn.dataset.copyBound = '1';
  btn.textContent = '📋';
  btn.classList.remove('del');
  btn.classList.add('copy');
  btn.title = '複製訂單資訊';
  btn.addEventListener('click', () => {
    const groupName = groupCard.querySelector('h3')?.textContent || '';
    const status = groupCard.querySelector('.groupHeader > select')?.value || '';
    const summaryText = groupCard.querySelector('.summaryText')?.textContent || '';
    const boxSummaryText = groupCard.querySelector('.summaryBoxText')?.textContent || '';
    const fullText = `${groupName}\n狀態: ${status}\n${summaryText}\n${boxSummaryText}`;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(fullText).then(() => {
        alert('訂單資訊已複製');
      }, () => {
        alert('複製失敗，請手動複製:\n' + fullText);
      });
    } else {
      const ta = document.createElement('textarea');
      ta.value = fullText;
      document.body.appendChild(ta);
      ta.select();
      try {
        document.execCommand('copy');
        alert('訂單資訊已複製');
      } catch (e) {
        if (e.name === 'AbortError') {
          console.log('使用者已取消匯出');
          return;
        }
        alert('複製失敗，請手動複製:\n' + fullText);
      }
      document.body.removeChild(ta);
    }
  });
}


function initAllSummaries() {
  document.querySelectorAll('.groupCard').forEach(g => { bindSummaryUpdater(g); bindCopyButton(g); });
}

document.addEventListener('DOMContentLoaded', () => {
  initAllSummaries();
});


function getBoxSummaryText(groupCard) {
  const decrypted = window.gridData;
  if (!decrypted) return '';

  const rows = decrypted.slice(10, 105);
  const ahOrder = rows.map(row => row[33]);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];

  const chunks = [];
  let currentChunk = [];

  for (const card of orderCards) {
    const selects = card.querySelectorAll('select');
    const hasContent = [...selects].some(s => s.value);
    if (hasContent) {
      currentChunk.push(card);
    } else {
      if (currentChunk.length) chunks.push(currentChunk);
      currentChunk = [];
    }
  }
  if (currentChunk.length) chunks.push(currentChunk);

  if (chunks.length <= 1) return '';
  const result = chunks.map(chunk => {
    const map = new Map();
    chunk.forEach(card => {
      const selects = card.querySelectorAll('select');
      const qtyInput = card.querySelector('input[type="number"]');
      const qty = parseInt(qtyInput?.value || '1');

      const itemA = selects[1]?.value;
      const itemB = selects[2]?.value;
      const accessories = [...selects].slice(3, 9).map(s => s.value).filter(Boolean);

      let shortA = '', shortB = '', itemType = '';
      if (itemA) {
        const row = rows.find(r => r[1] === itemA);
        if (row) { shortA = row[2]; itemType = row[0]; }
      }
      if (itemB) {
        const row = rows.find(r => r[1] === itemB);
        if (row) { shortB = row[2]; if (!itemType) itemType = row[0]; }
      }

      if (!shortA && !shortB) return;

      let baseName = '';
      if (shortA && shortB) {
        const sortedNames = [shortA, shortB].sort();
        baseName = `${sortedNames[0]}+${sortedNames[1]}`;
      } else if (shortB) {
        baseName = `${shortB}+${shortB}`;
      } else if (shortA) {
        baseName = shortA;
      }
      const accessoriesStr = accessories.length ? `(${accessories.join('+')})` : '';
      const fullName = `${baseName}${accessoriesStr}`;

      if (!map.has(fullName)) {
        map.set(fullName, { count: 0, type: itemType, index: map.size });
      }
      map.get(fullName).count += qty;
    });

    const sorted = [...map.entries()].sort((a, b) => {
      const idxA = ahOrder.indexOf(a[1].type);
      const idxB = ahOrder.indexOf(b[1].type);
      if (idxA !== idxB) return idxA - idxB;
      return a[1].index - b[1].index;
    });

    return `【${sorted.map(([name, val]) => `${name}X${val.count}`).join('；')}】`;
  });

  return result.join('');
}


function getItemPortionSummary(groupCard) {
  if (!window.gridData) return '';
  const rows = window.gridData.slice(10, 105);
  const ahOrder = rows.map(r => r[33]).filter(Boolean);
  const itemOrderMap = new Map(ahOrder.map((name, idx) => [name, idx]));

  const portionMap = new Map();
  const cards = [...groupCard.querySelectorAll('.orderCard')];

  for (const card of cards) {
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || '1');
    const a = selects[1]?.value;
    const b = selects[2]?.value;

    if (!a && !b) continue;

    const record = (val, q) => {
      const row = rows.find(r => r[1] === val); // B欄比對
      if (!row) return;
      const item = row[0]; // A欄品項
      const perPortion = parseFloat(row[30]); // AE欄
      if (!item || !perPortion || isNaN(perPortion)) return;
      if (!portionMap.has(item)) portionMap.set(item, { total: 0, perPortion });
      portionMap.get(item).total += q;
    };

    if (a && !b) record(a, qty);
    else if (!a && b) record(b, qty * 2);
    else {
      record(a, qty);
      record(b, qty);
    }
  }

  const result = [...portionMap.entries()]
    .sort((a, b) => (itemOrderMap.get(a[0]) ?? Infinity) - (itemOrderMap.get(b[0]) ?? Infinity))
    .map(([item, { total, perPortion }]) => {
      const intPart = Math.floor(total / perPortion);
      const remainder = total % perPortion;
      return `${item}${intPart}份${remainder ? '(不足份)' : ''}`;
    });

  return result.join('；');
}


// 🔄 更新 bindSummaryUpdater 以同時處理 summaryText 與 summaryBoxText




function getBoxSummaryText(groupCard) {
  const decrypted = window.gridData;
  if (!decrypted) return '';

  const rows = decrypted.slice(10, 105);
  const ahOrder = rows.map(r => r[33]);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];

  const chunks = [];
  let chunk = [], splitCount = 0;

  for (const card of orderCards) {
    const hasValue = [...card.querySelectorAll('select')].some(s => s.value);
    if (hasValue) {
      chunk.push(card);
    } else {
      if (chunk.length) chunks.push(chunk);
      chunk = [];
      splitCount++;
    }
  }
  if (chunk.length) chunks.push(chunk);
  if (chunks.length <= 1 || splitCount === 0) return '';

  return chunks.map(cards => {
    const map = new Map();
    cards.forEach(card => {
      const s = card.querySelectorAll('select');
      const qty = parseInt(card.querySelector('input[type="number"]')?.value || 1);
      const a = s[1]?.value, b = s[2]?.value;
      const acc = [...s].slice(3, 9).map(x => x.value).filter(Boolean);
      let sa = '', sb = '', type = '';

      for (const [val, set] of [[a, () => sa = rows.find(r => r[1] === a)?.[2]], [b, () => sb = rows.find(r => r[1] === b)?.[2]]]) {
        if (val) {
          const row = rows.find(r => r[1] === val);
          if (row) { if (!type) type = row[0]; if (set) set(); }
        }
      }

      if (!sa && !sb) return;
      const name = sa && sb ? [sa, sb].sort().join('+') : sa || `${sb}+${sb}`;
      const full = name + (acc.length ? `(${acc.join('+')})` : '');
      if (!map.has(full)) map.set(full, { count: 0, type, idx: map.size });
      map.get(full).count += qty;
    });

    return '【' + [...map.entries()]
      .sort((a, b) => ahOrder.indexOf(a[1].type) - ahOrder.indexOf(b[1].type) || a[1].idx - b[1].idx)
      .map(([k, v]) => `${k}X${v.count}`).join('；') + '】';
  }).join('');
}


let rows = [], rowsMap = new Map(), ahOrder = [];

function initGridDataCache() {
  if (!window.gridData) return;
  rows = window.gridData.slice(10, 105);
  ahOrder = rows.map(r => r[33]);
  rowsMap = new Map(rows.map(r => [r[1], { short: r[2], type: r[0] }]));
}


function summarizeChunk(cards) {
  const map = new Map();
  for (const card of cards) {
    const s = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || 1);
    const a = s[1]?.value, b = s[2]?.value;
    const acc = [];
    for (let i = 3; i < 9; i++) {
      const v = s[i]?.value;
      if (v) acc.push(v);
    }

    const ra = rowsMap.get(a), rb = rowsMap.get(b);
    const sa = ra?.short || '', sb = rb?.short || '';
    const type = ra?.type || rb?.type || '';

    if (!sa && !sb) continue;
    const name = sa && sb ? [sa, sb].sort().join('+') : sa || `${sb}+${sb}`;
    const full = acc.length ? `${name}(${acc.join('+')})` : name;

    if (!map.has(full)) map.set(full, { count: 0, type, idx: map.size });
    map.get(full).count += qty;
  }

  return [...map.entries()]
    .sort((a, b) => ahOrder.indexOf(a[1].type) - ahOrder.indexOf(b[1].type) || a[1].idx - b[1].idx)
    .map(([k, v]) => `${k}X${v.count}`);
}

function getBoxSummaryText(groupCard) {
  if (!window.gridData) return '';
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const chunks = [];
  let chunk = [], splitCount = 0;

  for (const card of orderCards) {
    const hasValue = [...card.querySelectorAll('select')].some(s => s.value);
    if (hasValue) {
      chunk.push(card);
    } else {
      if (chunk.length) chunks.push(chunk);
      chunk = [];
      splitCount++;
    }
  }
  if (chunk.length) chunks.push(chunk);
  if (chunks.length <= 1 || splitCount === 0) return '';

  return chunks.map(cards => '【' + summarizeChunk(cards).join('；') + '】').join('');
}

function getSummaryText(groupCard) {
  if (!window.gridData) return '';
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  return summarizeChunk(orderCards).join('；');
}



window.checkOrderColor = function(card) {
  const selects = card.querySelectorAll('select');
  const productA = selects[1]?.value;
  const productB = selects[2]?.value;
  const label = card.querySelector('.orderLabel');
  if (!label) return;
  if (productA || productB) {
    label.classList.remove('defaultRed');
  } else {
    label.classList.add('defaultRed');
  }
};

</script>

<script>
// ✅ 僅嵌入訂單金額邏輯（正確的A/B數量加乘）
function calculateTotalAmount(groupCard) {
  const grid = window.gridData;
  if (!grid) return 0;
  const rows = grid.slice(10, 105);
  const labelMap = grid[0];
  const comboQtyMap = grid[1];
  const specialPriceMap = grid[2];
  const payMethodMap = grid[3];
  const priceHeaders = grid[6].slice(15, 30);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';

  const totalItems = new Map();

  for (const card of orderCards) {
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || '1');
    const a = selects[1]?.value;
    const b = selects[2]?.value;

    const isValid = name => rows.some(r => r[1] === name);
    const validA = a && isValid(a);
    const validB = b && isValid(b);

    const add = (name, count) => {
      if (!name) return;
      if (!totalItems.has(name)) totalItems.set(name, 0);
      totalItems.set(name, totalItems.get(name) + count);
    };

    if (validA && !validB) {
      add(a, qty);
    } else if (!validA && validB) {
      add(b, qty * 2);
    } else if (validA && validB) {
      add(a, qty);
      add(b, qty);
    }
  }

  const specialsByLabel = new Map();
  const normalItems = [];

  for (const [name, count] of totalItems.entries()) {
    const row = rows.find(r => r[1] === name);
    if (!row) continue;
    const tag = row[3];
    const normalPriceRow = row.slice(15, 30);
    const priceIdx = priceHeaders.indexOf(payMethod);
    const unitPrice = parseFloat(normalPriceRow[priceIdx] || 0);

    if (tag && labelMap.includes(tag)) {
      const colIdx = labelMap.indexOf(tag);
      const allowedMethods = (payMethodMap[colIdx] || '').split('、');
      if (allowedMethods.includes(payMethod)) {
        if (!specialsByLabel.has(tag)) specialsByLabel.set(tag, []);
        specialsByLabel.get(tag).push({ price: unitPrice, count });
        continue;
      }
    }

    normalItems.push({ price: unitPrice, count });
  }

  let total = 0;
  for (const { price, count } of normalItems) total += price * count;

  for (const [tag, items] of specialsByLabel.entries()) {
    const colIdx = labelMap.indexOf(tag);
    const comboQty = parseInt(comboQtyMap[colIdx] || 0);
    const comboPrice = parseFloat(specialPriceMap[colIdx] || 0);
    const allUnits = [];
    for (const { price, count } of items) {
      for (let i = 0; i < count; i++) allUnits.push(price);
    }
    allUnits.sort((a, b) => b - a);
    const comboCount = Math.floor(allUnits.length / comboQty);
    total += comboCount * comboPrice;
    const remainder = allUnits.slice(comboCount * comboQty);
    for (const p of remainder) total += p;
  }

  return Math.round(total * 10) / 10;
}
// ---- 新增獨立折扣計算系統 (集點卡 + 滿份折) ----

function buildPortions(groupCard) {
  if (!window.gridData) return [];
  const grid = window.gridData;
  const rows = grid.slice(10, 105);
  const labelMap = grid[0];
  const comboQtyMap = grid[1];
  const specialPriceMap = grid[2];
  const payMethodMap = grid[3];
  const fullSetSpecialEligibilityRow = (grid[4] || []);
  const priceHeaders = grid[6].slice(15, 30);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';

  // 加權後的 item 數量（A/B 規則）
  const totalItems = new Map();
  for (const card of orderCards) {
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type="number"]')?.value || '1');
    const a = selects[1]?.value;
    const b = selects[2]?.value;
    const isValid = name => rows.some(r => r[1] === name);
    const validA = a && isValid(a);
    const validB = b && isValid(b);
    const add = (name, count) => {
      if (!name) return;
      totalItems.set(name, (totalItems.get(name) || 0) + count);
    };
    if (validA && !validB) {
      add(a, qty);
    } else if (!validA && validB) {
      add(b, qty * 2);
    } else if (validA && validB) {
      add(a, qty);
      add(b, qty);
    }
  }

  // 特價 vs 常價（常價再依 AF 欄拆出可折與不可折）
  const specialsByLabel = new Map();
  const discountableNormalItems = [];
  const nonDiscountableNormalItems = [];

  for (const [name, count] of totalItems.entries()) {
    const row = rows.find(r => r[1] === name);
    if (!row) continue;
    const tag = row[3];
    const normalPriceRow = row.slice(15, 30);
    const priceIdx = priceHeaders.indexOf(payMethod);
    const unitPrice = parseFloat(normalPriceRow[priceIdx] || 0);

    // 特價品邏輯
    if (tag && labelMap.includes(tag)) {
      const colIdx = labelMap.indexOf(tag);
      const allowedMethods = (payMethodMap[colIdx] || '').split('、');
      if (allowedMethods.includes(payMethod)) {
        if (!specialsByLabel.has(tag)) specialsByLabel.set(tag, []);
        specialsByLabel.get(tag).push({ price: unitPrice, count, row });
        continue;
      }
    }

    // 常價品依 AF 欄判定是否可折（row[31] 是 AF 欄）
    const afFlag = ((row[31] || '') + '').trim();
    if (afFlag === '是') {
      discountableNormalItems.push({ price: unitPrice, count, row });
    } else {
      nonDiscountableNormalItems.push({ price: unitPrice, count, row });
    }
  }

  const portions = [];
  // 特價組合（含餘數退回），都可折
  // 特價組合（含餘數退回），依 B5~O5 決定是否可參加滿份折扣
  for (const [tag, items] of specialsByLabel.entries()) {
    const colIdx = labelMap.indexOf(tag);
    const comboQty = parseInt(comboQtyMap[colIdx] || 0) || 0;
    const comboPrice = parseFloat(specialPriceMap[colIdx] || 0) || 0;

    // 建出每一個單位（保留 row 以便後續常價判定）
    const allUnits = [];
    for (const { price, count, row } of items) {
      for (let i = 0; i < count; i++) allUnits.push({ price, row });
    }
    allUnits.sort((a, b) => b.price - a.price);

    // 判斷該特價標籤是否有資格參加滿份折扣（B5~O5）
    const specialFullSetFlag = (((fullSetSpecialEligibilityRow[colIdx] || '') + '').trim() === '是');

    if (comboQty > 0) {
      const comboCount = Math.floor(allUnits.length / comboQty);
      for (let i = 0; i < comboCount; i++) {
        portions.push({
          price: comboPrice,
          type: 'special',
          label: tag,
          discountable: specialFullSetFlag
        });
      }
      const remainderUnits = allUnits.slice(comboCount * comboQty);
      for (const { price, row } of remainderUnits) {
        const afFlag = (((row[31] || '') + '').trim() === '是');
        const targetArr = afFlag ? discountableNormalItems : nonDiscountableNormalItems;
        const name = row[1];
        const existing = targetArr.find(e => (e.row && e.row[1]) === name);
        if (existing) {
          existing.count = (existing.count || 1) + 1;
        } else {
          targetArr.push({ price, count: 1, row });
        }
      }
    } else {
      // 如果 comboQty 為 0，整個標籤視為常價處理
      for (const { price, row } of allUnits) {
        const afFlag = (((row[31] || '') + '').trim() === '是');
        const targetArr = afFlag ? discountableNormalItems : nonDiscountableNormalItems;
        const name = row[1];
        const existing = targetArr.find(e => (e.row && e.row[1]) === name);
        if (existing) {
          existing.count = (existing.count || 1) + 1;
        } else {
          targetArr.push({ price, count: 1, row });
        }
      }
    }
  }


  // 常價可折部分
  for (const { price, count, row } of discountableNormalItems) {
    const perPortionQty = parseInt((row[30] || 0)) || 1;
    const fullPortions = Math.floor(count / perPortionQty);
    const remainderUnits = count % perPortionQty;
    for (let i = 0; i < fullPortions; i++) {
      portions.push({
        price: price * perPortionQty,
        type: 'normal',
        label: null,
        isFullPortion: true,
        discountable: true,
        row: row
      });
    }
    if (remainderUnits > 0) {
      portions.push({
        price: price * remainderUnits,
        type: 'normal',
        label: null,
        isFullPortion: false,
        remainder: remainderUnits,
        discountable: true,
        row: row
      });
    }
  }

  // 常價不可折部分（仍出現在金額，但 discountable: false）
  for (const { price, count, row } of nonDiscountableNormalItems) {
    const perPortionQty = parseInt((row[30] || 0)) || 1;
    const fullPortions = Math.floor(count / perPortionQty);
    const remainderUnits = count % perPortionQty;
    for (let i = 0; i < fullPortions; i++) {
      portions.push({
        price: price * perPortionQty,
        type: 'normal',
        label: null,
        isFullPortion: true,
        discountable: false,
        row: row
      });
    }
    if (remainderUnits > 0) {
      portions.push({
        price: price * remainderUnits,
        type: 'normal',
        label: null,
        isFullPortion: false,
        remainder: remainderUnits,
        discountable: false,
        row: row
      });
    }
  }

  // 依價格高至低排序
  portions.sort((a, b) => b.price - a.price);
  return portions;
}


function applyPointCardDiscount(portions, cardCount, perCardCap) {
  let discount = 0;
  let usedCards = 0;
  const used = new Set();
  for (let c = 0; c < cardCount; c++) {
    const idx = portions.findIndex((p, i) => !used.has(i) && p.price <= perCardCap);
    if (idx === -1) break;
    discount += portions[idx].price;
    used.add(idx);
    usedCards++;
  }
  const remaining = portions.filter((_, i) => !used.has(i));
  return { discount, remaining, usedCards };
}

function applyFullPortionDiscount(portions, X, Y) {
  let discount = 0;
  let freeCount = 0;
  if (X <= 0 || Y <= 0) return { discount, freeCount };
  // 每 X 份一組，該組最後 Y 份免費，但僅限完整組
  for (let blockStart = 0; blockStart + X <= portions.length; blockStart += X) {
    const block = portions.slice(blockStart, blockStart + X);
    for (let j = X - Y; j < X; j++) {
      discount += block[j].price;
      freeCount++;
    }
  }
  return { discount, freeCount };
}

function getPaymentWeight(groupCard) {
  if (!window.gridData) return 1;
  const grid = window.gridData;
  const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';
  const priceHeaders = grid[6].slice(15, 30);
  const weightRow = (grid[8] || []).slice(15, 30);
  const idx = priceHeaders.indexOf(payMethod);
  if (idx === -1) return 1;
  const w = parseFloat(weightRow[idx] || 1);
  return isNaN(w) ? 1 : w;
}


function computeIndependentDiscounts(groupCard) {
  const orderAmount = calculateTotalAmount(groupCard);
  const allPortions = buildPortions(groupCard);
  // 判定支付方式是否有折扣資格（參考 P5~AD5，grid index 4 對應 Excel 第5列）
  const priceHeaders = (window.gridData && window.gridData[6] || []).slice(15, 30);
  const eligibilityRow = (window.gridData && window.gridData[4] || []).slice(15, 30);
  const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';
  let discountAllowed = true;
  const idx = priceHeaders.indexOf(payMethod);
  if (idx === -1) discountAllowed = false;
  else if (((eligibilityRow[idx] || '') + '').trim() !== '是') discountAllowed = false;

  // 分出可折與不可折
  const eligiblePortions = allPortions.filter(p => p.discountable !== false);
  const ineligiblePortions = allPortions.filter(p => p.discountable === false);

  // 取集點卡資訊
  let pointCardCap = 0, pointCardCount = 0;
  const pointCardLabel = [...document.querySelectorAll('label')].find(l => l.textContent.includes('點卡折抵上限'));
  if (pointCardLabel) {
    const input = pointCardLabel.querySelector('input');
    pointCardCap = parseFloat(input?.value || 0);
  }
  const exchangeLabel = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('集點卡兌換數量'));
  if (exchangeLabel) {
    const input = exchangeLabel.querySelector('input');
    pointCardCount = parseInt(input?.value || 0);
  }

  let pointCardDiscount = 0, usedCards = 0;
  let remainingEligible = eligiblePortions;

  if (discountAllowed) {
    const resPoint = applyPointCardDiscount(remainingEligible, pointCardCount, pointCardCap);
    pointCardDiscount = resPoint.discount;
    remainingEligible = resPoint.remaining;
    usedCards = resPoint.usedCards;
  }

  let fullPortionDiscount = 0, freeCount = 0;
  let fullX = 0, fullY = 0;
  const fullPortionLabel = [...document.querySelectorAll('label')].find(l => l.textContent.includes('份折') && !l.textContent.includes('點卡折抵'));
  if (fullPortionLabel) {
    const inputs = fullPortionLabel.querySelectorAll('input');
    if (inputs.length >= 2) {
      fullX = parseInt(inputs[0]?.value || 0);
      fullY = parseInt(inputs[1]?.value || 0);
    }
  }

  if (discountAllowed) {
    const resFull = applyFullPortionDiscount(remainingEligible, fullX, fullY);
    fullPortionDiscount = resFull.discount;
    freeCount = resFull.freeCount;
  }

  const adjustment = parseFloat(groupCard.querySelector('.adjustInput')?.value || 0) || 0;
  const paymentWeight = getPaymentWeight(groupCard);
  const intermediate = orderAmount - pointCardDiscount - fullPortionDiscount + adjustment;
  const checkout = Math.round(intermediate * paymentWeight * 100) / 100;
  return {
    orderAmount,
    pointCard: { usedCards, discount: pointCardDiscount },
    fullPortion: { freeCount, discount: fullPortionDiscount },
    adjustment,
    paymentWeight,
    checkout,
    points: computePoints(groupCard, {
      orderAmount,
      pointCard: { usedCards, discount: pointCardDiscount },
      fullPortion: { freeCount, discount: fullPortionDiscount },
      adjustment,
      paymentWeight,
      checkout
    })
  };
}


// ---- 新增點數發放計算 ----
function computePoints(groupCard, info) {
  if (!window.gridData) return { fullCyclePoints:0, leftoverPoints:0, containerPoints:0, totalPoints:0 };
  const grid = window.gridData;
  // 讀 UI 的門檻：滿N元N點
  let moneyThreshold = 0, pointsPerMoney = 0;
  const moneyLabel = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('元') && l.textContent.includes('點'));
  if (moneyLabel) {
    const inputs = moneyLabel.querySelectorAll('input');
    if (inputs.length >= 2) {
      moneyThreshold = parseFloat(inputs[0]?.value || 0);
      pointsPerMoney = parseFloat(inputs[1]?.value || 0);
    }
  }
  // 讀滿N份乘N倍（剩餘加權）
  let setThreshold = 0, setMultiplier = 1;
  const setLabel = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('份乘'));
  if (setLabel) {
    const inputs = setLabel.querySelectorAll('input');
    if (inputs.length >= 2) {
      setThreshold = parseFloat(inputs[0]?.value || 0);
      setMultiplier = parseFloat(inputs[1]?.value || 0);
    }
  }
  // 讀滿份折的 X (每組大小) 與 Y (每組免費份數)
  let fullX = 0, fullY = 0;
  const fullPortionLabel = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('份折') && !l.textContent.includes('點卡折抵'));
  if (fullPortionLabel) {
    const inputs = fullPortionLabel.querySelectorAll('input');
    if (inputs.length >= 2) {
      fullX = parseInt(inputs[0]?.value || 0);
      fullY = parseInt(inputs[1]?.value || 0);
    }
  }
  // 計算完整循環數（freeCount / fullY）
  const freeCount = info.fullPortion.freeCount || 0;
  const cycles = fullY > 0 ? Math.floor(freeCount / fullY) : 0;
  // 每一個循環給的點數 = pointsPerMoney
  const fullCyclePoints = cycles * pointsPerMoney;

  // 取得所有 portions
  const allPortions = buildPortions(groupCard);
  // 先處理被集點卡折掉的 portions：從原本參加滿份折扣的 eligiblePortions 中移除點卡使用掉的那部分
  const eligiblePortions = allPortions.filter(p => p.discountable !== false);
  // 取集點卡資訊（為了排除已被點卡折抵的 portion）
  let pointCardCountLocal = 0, pointCardCapLocal = 0;
  const pointCardLabelLocal = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('集點卡兌換數量'));
  if (pointCardLabelLocal) {
    const input = pointCardLabelLocal.querySelector('input');
    pointCardCountLocal = parseInt(input?.value || 0);
  }
  const pointCardCapLabelLocal = [...document.querySelectorAll('label')].find(l => l.textContent.includes('點卡折抵上限'));
  if (pointCardCapLabelLocal) {
    const input = pointCardCapLabelLocal.querySelector('input');
    pointCardCapLocal = parseFloat(input?.value || 0);
  }
  // apply point card discount to eligiblePortions to get remaining eligible after point card removal
  const resPointLocal = applyPointCardDiscount(eligiblePortions, pointCardCountLocal, pointCardCapLocal);
  const remainingEligibleAfterPointCard = resPointLocal.remaining;
  // 取出滿份已使用的 portions（每個循環 consume fullX 份），這裡使用 remainingEligibleAfterPointCard
  const usedCount = cycles * fullX;
  const leftoverFromEligible = remainingEligibleAfterPointCard.slice(usedCount);
  // 一開始沒有參加滿份折的（不可折部分）
  const neverIncluded = allPortions.filter(p => p.discountable === false);
  // 合併為剩下要再做點數資格判斷的 pool
  const leftoverPool = [...leftoverFromEligible, ...neverIncluded];

  // 判斷某一 portion 是否有點數資格
  function portionEligibleForPoints(p) {
    if (!grid) return false;
    // 特價品用標籤去看 B6~O6（假設在 grid[0] 找到 tag 再看 row 6 是否為 '是'）
    if (p.type === 'special') {
      const tag = p.label;
      if (!tag) return false;
      const labelMap = grid[0] || [];
      const idx = labelMap.indexOf(tag);
      if (idx === -1) return false;
      const row6 = (grid[5] || []);
      return ((row6[idx] || '') + '').trim() === '是';
    }
    // 常價（看 AG 欄位）
    if (p.row) {
      const agFlag = ((p.row[32] || '') + '').trim();
      return agFlag === '是';
    }
    return false;
  }

  // 計算剩餘符合資格的金額與份數
  let leftoverAmount = 0;
  let leftoverSetCount = 0;
  leftoverPool.forEach(p => {
    if (!portionEligibleForPoints(p)) return;
    leftoverAmount += p.price || 0;
    if (p.isFullPortion) leftoverSetCount += 1;
    else if (p.remainder) leftoverSetCount += p.remainder;
    else leftoverSetCount += 1;
  });

  // 基底點數（滿N元N點）
  let leftoverPoints = 0;
  if (moneyThreshold > 0) {
    const basePoints = Math.floor(leftoverAmount / moneyThreshold) * pointsPerMoney;
    if (leftoverSetCount >= setThreshold && setThreshold > 0) {
      leftoverPoints = basePoints * setMultiplier;
    } else {
      leftoverPoints = basePoints;
    }
  }

  // 自備容器（加碼）
  let containerPoints = 0;
  const selfContainerChecked = !!groupCard.querySelector('input[type="checkbox"]')?.checked;
  if (selfContainerChecked && pointsPerMoney > 0) {
    containerPoints = pointsPerMoney;
  }

  let paymentMethodEligible = true;
  if (window.gridData) {
    const grid = window.gridData;
    const payMethod = groupCard.querySelectorAll('.rowLine select')[1]?.value || '';
    const priceHeaders = (grid[6] || []).slice(15, 30);
    const methodIdx = priceHeaders.indexOf(payMethod);
    if (methodIdx !== -1) {
      const eligibilityRow = (grid[2] || []).slice(15, 30);
      if (((eligibilityRow[methodIdx] || '') + '').trim() !== '是') {
        paymentMethodEligible = false;
      }
    }
  }
  if (!paymentMethodEligible) {
    return { fullCyclePoints:0, leftoverPoints:0, containerPoints:0, totalPoints:0 };
  }
  const totalPoints = fullCyclePoints + leftoverPoints + containerPoints;
  return { fullCyclePoints, leftoverPoints, containerPoints, totalPoints };
}


// ---- 新增整日訂單結算功能 ----
function formatMoney(n){ return (Math.round(n*100)/100).toFixed(2); }


function computeGroupCost(groupCard){
  if (!window.gridData) return 0;
  const grid = window.gridData;
  const rows = grid.slice(10, 105);
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];
  const totalItems = new Map();
  for (const card of orderCards){
    const selects = card.querySelectorAll('select');
    const qtyInput = card.querySelector('input[type="number"]');
    const qty = parseInt(qtyInput?.value || '1');
    const itemA = selects[1]?.value;
    const itemB = selects[2]?.value;
    const isValid = name => rows.some(r => r[1] === name);
    const add = (name, count) => {
      if (!name) return;
      totalItems.set(name, (totalItems.get(name) || 0) + count);
    };
    const validA = itemA && isValid(itemA);
    const validB = itemB && isValid(itemB);
    if (validA && !validB){
      add(itemA, qty);
    } else if (!validA && validB){
      add(itemB, qty * 2);
    } else if (validA && validB){
      add(itemA, qty);
      add(itemB, qty);
    }
  }
  let totalCost=0;
  for (const [name, count] of totalItems.entries()){
    const row = rows.find(r => r[1] === name);
    if (!row) continue;
    const costPerUnit = parseFloat(row[4]) || 0;
    totalCost += costPerUnit * count;
  }
  return Math.round(totalCost * 100)/100;
}


function updateDailySummary(){
  const groupCards = [...document.querySelectorAll('.groupCard')];
  let totalOrder=0;
  let totalPointCardUsed=0;
  let totalPointCardDiscount=0;
  let totalFullPortionCount=0;
  let totalFullPortionDiscount=0;
  let totalAdjustment=0;
  let totalCheckout=0;
  let totalPoints=0;
  let waitingMinutes = 0;
  let totalSelfContainerChecked=0;
  const paymentMethodTotals = {};
  const paymentMethodCostTotals = {};
  let totalCost = 0;
  for(const group of groupCards){
    const statusSelect = group.querySelector('.groupHeader > select');
    if (statusSelect && statusSelect.value === '取消訂單') continue;

    // accumulate waiting time for orders that are waiting to be produced
    if (statusSelect && (statusSelect.value === '未結待製' || statusSelect.value === '已結待製')) {
      const prod = computeProductionTime(group);
      waitingMinutes += (prod.hours * 60 + prod.minutes);
    }
    const info = computeIndependentDiscounts(group);
    totalOrder += (info.orderAmount || 0);
    totalPointCardUsed += (info.pointCard?.usedCards || 0);
    totalPointCardDiscount += (info.pointCard?.discount || 0);
    totalFullPortionCount += (info.fullPortion?.freeCount || 0);
    totalFullPortionDiscount += (info.fullPortion?.discount || 0);
    totalAdjustment += (info.adjustment || 0);
    totalCheckout += (info.checkout || 0);
    totalPoints += (info.points?.totalPoints || 0);
    const selfContainerCheckbox = [...group.querySelectorAll('label')].find(l=> l.textContent.includes('自備容器'))?.querySelector('input[type="checkbox"]');
    if (selfContainerCheckbox?.checked) totalSelfContainerChecked++;
    const groupCost = computeGroupCost(group);
    totalCost += groupCost;
    // payment method grouping
    const paymentSelect = [...group.querySelectorAll('select')].find(s=> s.options[0] && s.options[0].textContent==='支付方式');
    let pm = '';
    if(paymentSelect){
      const val = paymentSelect.value;
      if(val && val.trim()!=='' && val.trim()!=='支付方式') pm = val;
    }
    if(pm){
      paymentMethodTotals[pm] = (paymentMethodTotals[pm]||0) + (info.checkout||0);
      paymentMethodCostTotals[pm] = (paymentMethodCostTotals[pm]||0) + groupCost;
    }
  }
  const totalsEl = document.getElementById('dailyTotals');
  const breakdownEl = document.getElementById('paymentBreakdown');
  const overallProfitPercent = totalCheckout ? (1 - (totalCost / totalCheckout)) * 100 : 0;
  const overallProfitText = totalCheckout ? `(${overallProfitPercent.toFixed(2)}%)` : '(0.00%)';
  const waitHours = Math.floor(waitingMinutes/60);
  const waitMins = waitingMinutes % 60;
  const waitingStr = `目前等待時間${waitHours}時${waitMins}分；`;
  const totalSummary = `${waitingStr}整日合計：訂單金額 ${formatMoney(totalOrder)} 元；集點卡兌換 ${formatMoney(totalPointCardDiscount)} 元；滿份折 ${formatMoney(totalFullPortionDiscount)} 元；金額調整 ${formatMoney(totalAdjustment)} 元；結帳金額 ${formatMoney(totalCheckout)} 元${overallProfitText}；${Math.round(totalPoints)} 點；自備容器 ${totalSelfContainerChecked}`;
  if(totalsEl) totalsEl.textContent = totalSummary;
  const parts = [];
  for(const m in paymentMethodTotals){
    if(Object.hasOwn(paymentMethodTotals,m)){
      const pmCheckout = paymentMethodTotals[m];
      const pmCost = paymentMethodCostTotals[m] || 0;
      const pmProfitPercent = pmCheckout ? (1 - (pmCost / pmCheckout)) * 100 : 0;
      parts.push(`${m}: ${formatMoney(pmCheckout)} 元(${pmProfitPercent.toFixed(2)}%)`);
    }
  }
  if(breakdownEl) breakdownEl.textContent = parts.length ? '支付方式小計：' + parts.join('；') : '';
}


// 每次 summary 更新後也 update daily
function updateAllDailySummary(){
  updateDailySummary();
}


// ---- 結束獨立折扣系統 ----

// ✅ 乾淨的 summary updater（只留這個一個實作）

// ✅ 乾淨的 summary updater（擴充訂單資訊：來源、支付方式、註記、外送、時間）

// === 新增：製作時間估算 helper ===
function getOvenBatchSeconds() {
  const label = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('烤盤計時'));
  if (!label) return 0;
  const inputs = label.querySelectorAll('input');
  let min = parseInt(inputs[0]?.value || '0', 10);
  let sec = parseInt(inputs[1]?.value || '0', 10);
  if (isNaN(min)) min = 0;
  if (isNaN(sec)) sec = 0;
  return (min * 60) + sec;
}
function getPerPieceSeconds() {
  const label = [...document.querySelectorAll('.stickyBar label')].find(l => l.textContent.includes('顆秒'));
  if (!label) return 0;
  const input = label.querySelector('input');
  const sec = parseInt(input?.value || '0', 10);
  if (isNaN(sec)) return 0;
  return sec;
}
function computeProductionTime(groupCard){
  const perPieceSeconds = getPerPieceSeconds();
  const ovenBatchSeconds = getOvenBatchSeconds();
  let totalPieces = 0;
  const orderCards = [...groupCard.querySelectorAll('.orderCard')];

  // 建立從 B 欄商品名稱對應到 A 欄品項類別的 map（A11~A106 對應 index 10~105）
  const targetCategories = new Set(['雞蛋糕', '餅乾']);
  let productCategoryMap = null;
  if (window.gridData) {
    const rows = window.gridData.slice(10, 106); // 包含 A11~A106
    productCategoryMap = new Map(rows.map(r => [r[1], (r[0] || '').trim()]));
  }

  function isTargetProduct(name){
    if (!name) return false;
    const normalized = name.trim();
    if (normalized.includes('雞蛋糕') || normalized.includes('餅乾')) return true;
    if (productCategoryMap) {
      const category = productCategoryMap.get(normalized);
      if (category && targetCategories.has(category)) return true;
    }
    return false;
  }

  for (const card of orderCards){
    const selects = card.querySelectorAll('select');
    const qty = parseInt(card.querySelector('input[type=\"number\"]')?.value || '1', 10);
    const a = selects[1]?.value || '';
    const b = selects[2]?.value || '';
    const validA = isTargetProduct(a);
    const validB = isTargetProduct(b);
    if (validA && !validB){
      totalPieces += qty;
    } else if (!validA && validB){
      totalPieces += qty * 2;
    } else if (validA && validB){
      totalPieces += qty * 2;
    }
  }

  const processingSeconds = totalPieces * perPieceSeconds;
  const batches = Math.ceil(totalPieces / 12);
  const ovenSecondsTotal = batches * ovenBatchSeconds;
  const totalSeconds = processingSeconds + ovenSecondsTotal;
  const totalMinutes = Math.ceil(totalSeconds / 60);
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  return { hours, minutes, totalPieces };
}

function bindSummaryUpdater(groupCard) {
  const getItemPortionSummary = window.getItemPortionSummary || (() => '');
  const summaryDiv = groupCard.querySelector('.summaryText');
  const summaryBox = groupCard.querySelector('.summaryBoxText');
  const inputs = groupCard.querySelectorAll('select, input[type="number"]');
  let lastSummary = '', lastBox = '';

  function update() {
    let portionSummary = getItemPortionSummary(groupCard);
    const baseSummary = getSummaryText(groupCard);
    const prodTime = computeProductionTime(groupCard);
    let itemSummaryLine = baseSummary;
    if (prodTime.totalPieces > 0) {
      if (portionSummary) {
        portionSummary += ` 預計製作時間${prodTime.hours}時${String(prodTime.minutes).padStart(2,'0')}分`;
      } else {
        itemSummaryLine += ` 預計製作時間${prodTime.hours}時${String(prodTime.minutes).padStart(2,'0')}分`;
      }
    }

    const boxSummary = getBoxSummaryText(groupCard);
    const info = computeIndependentDiscounts(groupCard);
    const fmt = n => (Math.round(n * 100) / 100).toFixed(2);
    const orderAmountText = fmt(info.orderAmount);
    const pointCardCount = info.pointCard.usedCards;
    const pointCardDiscount = fmt(info.pointCard.discount);
    const fullPortionCount = info.fullPortion.freeCount;
    const fullPortionDiscount = fmt(info.fullPortion.discount);
    const adjustmentText = fmt(info.adjustment);
    const checkoutText = fmt(info.checkout);
    let pointsText = `點數發放 ${info.points?.totalPoints || 0} 點`;
    if (info.points?.containerPoints > 0) {
      pointsText += ' (自備容器)';
    }
    const summaryMain = `訂單金額 ${orderAmountText} 元；集點卡兌換 ${pointCardCount} 份 ${pointCardDiscount} 元；滿份折 ${fullPortionCount} 份 ${fullPortionDiscount} 元；金額調整 ${adjustmentText} 元；結帳金額 ${checkoutText} 元；${pointsText}`;

    let extraParts = [];
    // 顧客來源
    
    // 顧客來源與時間（時間在前）
    let customerSourcePart = '';
    const sourceSelect = [...groupCard.querySelectorAll('select')].find(s => s.options[0] && s.options[0].textContent.trim() === '顧客來源');
    let customerSourceValue = '';
    if (sourceSelect) {
      const val = sourceSelect.value;
      if (val && val.trim() !== '' && val.trim() !== '顧客來源') customerSourceValue = val.trim();
    }
    const sourceTime = groupCard.dataset.customerSourceTime;
    if (customerSourceValue) {
      if (sourceTime) {
        customerSourcePart = `${sourceTime} ${customerSourceValue}`;
      } else {
        customerSourcePart = customerSourceValue;
      }
    }
    if (customerSourcePart) extraParts.push(customerSourcePart);

    // 支付方式：排除預設 placeholder "支付方式"
    let paymentMethod = '';
    const paymentSelect = [...groupCard.querySelectorAll('select')].find(s => s.options[0] && s.options[0].textContent === '支付方式');
    if (paymentSelect) {
      const val = paymentSelect.value;
      if (val && val.trim() !== '' && val.trim() !== '支付方式') paymentMethod = val;
    }
    if (!paymentMethod) {
      const paymentLabel = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('支付方式'));
      if (paymentLabel) {
        const sel = paymentLabel.querySelector('select');
        const inp = paymentLabel.querySelector('input');
        const val = sel?.value || inp?.value || '';
        if (val && !val.includes('支付方式')) paymentMethod = val;
      }
    }
    if (paymentMethod) extraParts.push(paymentMethod);
    // 註記
    const note = [...groupCard.querySelectorAll('label')].find(l=>l.textContent.includes('註記'))?.querySelector('input')?.value || '';
    if (note) extraParts.push(note);
    // 外送資訊
    const deliveryInfoLabel = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('外送資訊'));
    const deliveryInfo = deliveryInfoLabel?.querySelector('input')?.value || '';
    // 萬年表時間
    const timeVal = groupCard.querySelector('input[type=\\"datetime-local\\"]')?.value || '';
    let timelineText = '';
    if (timeVal) {
      const dt = new Date(timeVal);
      const pad = n => n.toString().padStart(2, '0');
      const dateStr = `${dt.getFullYear()}/${pad(dt.getMonth()+1)}/${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}`;
      if (deliveryInfo) {
        timelineText = `${dateStr}送達`;
      } else {
        timelineText = `${dateStr}取餐`;
      }
    }
    if (deliveryInfo) extraParts.push(deliveryInfo);
    if (timelineText) extraParts.push(timelineText);
    // 額外補強萬年曆顯示（若前面沒出現但 span 有顯示）
    const pickupSpanEl = groupCard.querySelector('.pickupText');
    const deliverySpanEl = groupCard.querySelector('.deliveryText');
    if (pickupSpanEl && pickupSpanEl.style.display !== 'none' && pickupSpanEl.textContent.trim()) {
      if (!extraParts.includes(pickupSpanEl.textContent.trim())) extraParts.push(pickupSpanEl.textContent.trim());
    }
    if (deliverySpanEl && deliverySpanEl.style.display !== 'none' && deliverySpanEl.textContent.trim()) {
      if (!extraParts.includes(deliverySpanEl.textContent.trim())) extraParts.push(deliverySpanEl.textContent.trim());
    }


    const statusSelectForSummary = groupCard.querySelector('.groupHeader > select');
    let fullSummaryMain = summaryMain;
    if (statusSelectForSummary && statusSelectForSummary.value === '取消訂單') {
      fullSummaryMain = '取消訂單 ' + summaryMain;
    }
    let full = fullSummaryMain;
    if (extraParts.length) full += '\n' + extraParts.join('；');
    if (portionSummary) {
      full += '\n' + portionSummary + '\n' + itemSummaryLine;
    } else {
      full += '\n' + itemSummaryLine;
    }
    if (full !== lastSummary) summaryDiv.textContent = lastSummary = full;
    if (boxSummary !== lastBox) summaryBox.textContent = lastBox = boxSummary;
    if (typeof updateDailySummary === 'function') updateDailySummary();
  }

  inputs.forEach(input => {
    input.addEventListener('change', update);
    input.addEventListener('input', update);
  });
  // 自備容器 checkbox 也要即時更新
  const containerCheckbox = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('自備容器'))?.querySelector('input[type="checkbox"]');
  if (containerCheckbox) {
    containerCheckbox.addEventListener('change', update);
  }
  // 額外監聽：註記、外送資訊、時間
  const noteInput = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('註記'))?.querySelector('input');
  const deliveryInput = [...groupCard.querySelectorAll('label')].find(l => l.textContent.includes('外送資訊'))?.querySelector('input');
  const timeInput = groupCard.querySelector('input[type="datetime-local"]');
  [noteInput, deliveryInput, timeInput].forEach(el => {
    if (!el) return;
    el.addEventListener('input', update);
    el.addEventListener('change', update);
  });
  update();
}



// ✅ 僅調整摘要顯示金額（不動其他邏輯）

</script>


<script>
// 重做的穩定匯出 / 匯入 TXT 功能（版本升級 V1.01.28）
document.addEventListener("DOMContentLoaded", () => {
  // 保留一個乾淨的 group 範本
  const container = window.findGroupContainer();
  const originalGroup = document.querySelector(".groupCard");
  let groupTemplate = null;
  if (originalGroup) {
    groupTemplate = originalGroup.cloneNode(true);
  }

  function gatherExportData() {
    const totalsEl = document.getElementById('dailyTotals');
    const breakdownEl = document.getElementById('paymentBreakdown');
    const dailySummaryText =
      (totalsEl?.textContent || '') +
      (breakdownEl?.textContent ? '\n' + breakdownEl.textContent : '');

    const groupsData = [...document.querySelectorAll('.groupCard')].map(group => {
      const name = group.querySelector('h3')?.textContent || '';
      const status = group.querySelector('.groupHeader > select')?.value || '';
      const customerSource = [...group.querySelectorAll('.rowLine select')]
        .find(s => s.options[0]?.textContent === '顧客來源')?.value || '';
      const paymentMethod = [...group.querySelectorAll('.rowLine select')]
        .find(s => s.options[0]?.textContent === '支付方式')?.value || '';
      const note = group.querySelector('input[placeholder="註記"]')?.value || '';
      const datetime = group.querySelector('input[type="datetime-local"]')?.value || '';
      const deliveryInfo = [...group.querySelectorAll('label')]
        .find(l => l.textContent.includes('外送資訊'))?.querySelector('input')?.value || '';
      const getLabelInputValue = text =>
        [...group.querySelectorAll('label')]
          .find(l => l.textContent.includes(text))?.querySelector('input')?.value || '';
      const pointCards = getLabelInputValue('集點卡兌換數量');
      const adjustment = getLabelInputValue('金額調整');
      const selfContainer = !![...group.querySelectorAll('label')]
        .find(l => l.textContent.includes('自備容器'))?.querySelector('input')?.checked;
      const customerSourceTime = group.dataset.customerSourceTime || '';
      const orders = [...group.querySelectorAll('.orderCard')].map(card => {
        const rowLines = card.querySelectorAll('.rowLine');
        const item = rowLines[0]?.querySelector('select')?.value || '';
        const quantity = rowLines[0]?.querySelector('input[type=\"number\"]')?.value || '';
        const productA = rowLines[1]?.querySelectorAll('select')[0]?.value || '';
        const productB = rowLines[1]?.querySelectorAll('select')[1]?.value || '';
        const accessories = Array.from(rowLines[1]?.querySelectorAll('select') || [])
          .slice(2, 8)
          .map(s => s.value || '');
        return { item, quantity, productA, productB, accessories };
      });

      return {
        name,
        status,
        customerSource,
        customerSourceTime,
        paymentMethod,
        note,
        datetime,
        deliveryInfo,
        pointCards,
        adjustment,
        selfContainer,
        orders
      };
    });

    return {
      exportedAt: new Date().toISOString(),
      dailySummary: dailySummaryText,
      groups: groupsData
    };
  }

  async function exportToTxt() {
    const exportObj = gatherExportData();
    let text = '';
    if (exportObj && exportObj.groups) {
      text += `整日合計：${exportObj.dailySummary}\n\n`;
      for (const g of exportObj.groups) {
        text += `第 ${g.name.replace(/第\\s*/, '')} 組客人（狀態：${g.status}）：\n`;
        text += `  顧客來源: ${g.customerSource} ${g.customerSourceTime || ''}\n`;
        text += `  支付方式: ${g.paymentMethod}\n`;
        text += `  註記: ${g.note}\n`;
        text += `  時間: ${g.datetime}\n`;
        text += `  外送資訊: ${g.deliveryInfo}\n`;
        text += `  集點卡兌換數量: ${g.pointCards}\n`;
        text += `  金額調整: ${g.adjustment}\n`;
        text += `  自備容器: ${g.selfContainer}\n`;
        for (let i = 0; i < g.orders.length; i++) {
          const o = g.orders[i];
          const acc = o.accessories.filter(a => a).join('+');
          text += `  第 ${i + 1} 組訂單: 品項=${o.item}, 數量=${o.quantity}, 商品A=${o.productA}, 商品B=${o.productB}, 附=${acc}\n`;
        }
        text += '\n';
      }
    }
    const exportObjFull = gatherExportData();
    text += `---JSON-EXPORT-START---\n${JSON.stringify(exportObjFull)}\n---JSON-EXPORT-END---\n`;

    if (window.showSaveFilePicker) {
      try {
        const opts = {
          suggestedName: `訂單備份_${new Date().toISOString().slice(0, 10)}.txt`,
          types: [{
            description: 'Text file',
            accept: { 'text/plain': ['.txt'] }
          }]
        };
        const handle = await window.showSaveFilePicker(opts);
        const writable = await handle.createWritable();
        await writable.write(text);
        await writable.close();
        alert('匯出完成，已儲存至選定位置');
        return;
      } catch (e) {
        if (e.name === 'AbortError') {
          console.log('使用者已取消匯出');
          return;
        }
        console.warn('showSaveFilePicker failed, fallback to anchor download', e);
      }
    }
    const blob = new Blob([text], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `訂單備份_${new Date().toISOString().slice(0, 10)}.txt`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 5000);
  }

  
  
  async function importFromTxt() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.txt,text/plain';
    input.addEventListener('change', async () => {
      const file = input.files[0];
      if (!file) return;
      const text = await file.text();
      const m = text.match(/---JSON-EXPORT-START---\s*([\s\S]*?)\s*---JSON-EXPORT-END---/);
      if (!m) { alert('找不到匯出格式中的 JSON 資訊'); return; }
      let obj;
      try { obj = JSON.parse(m[1]); } catch (e) { alert('解析 JSON 失敗: ' + e); return; }

      // 找到群組容器並清空
      const container = window.findGroupContainer ? window.findGroupContainer() : document.querySelector('.groupsContainer');
      if (!container) { alert('找不到群組容器'); return; }
      document.querySelectorAll('.groupCard').forEach(g => g.remove());

      // 逐組匯入客人
      for (const g of obj.groups) {
        const addCustomerBtn = document.querySelector('.stickyBar .btn.add');
        if (!addCustomerBtn) { alert('找不到「新增客人」按鈕'); break; }
        const prevCount = container.querySelectorAll('.groupCard').length;
        addCustomerBtn.click();
        // 等待新群組節點出現
        await new Promise(resolve => {
          const interval = setInterval(() => {
            const count = container.querySelectorAll('.groupCard').length;
            if (count > prevCount) {
              clearInterval(interval);
              resolve();
            }
          }, 50);
        });
        const groups = container.querySelectorAll('.groupCard');
        const newGroup = groups[groups.length - 1];
        if (!newGroup) { alert('無法建立新群組'); return; }

        // 設定群組名稱
        const h3 = newGroup.querySelector('h3');
        if (h3) h3.textContent = g.name;

        // 初始化群組功能
        if (typeof initGroup === 'function') initGroup(newGroup);
        if (window.bindItemSelectLogic) window.bindItemSelectLogic(newGroup);
        if (typeof window.populatePaymentOptions === 'function') window.populatePaymentOptions(newGroup);
        if (typeof bindCopyButton === 'function') bindCopyButton(newGroup);
        if (typeof bindSummaryUpdater === 'function') bindSummaryUpdater(newGroup);

        // 填入欄位
        const statusSel = newGroup.querySelector('.groupHeader > select');
        if (statusSel) { statusSel.value = g.status; statusSel.dispatchEvent(new Event('change', { bubbles: true })); }
        const customerSourceSel = [...newGroup.querySelectorAll('.rowLine select')].find(s => s.options[0]?.textContent === '顧客來源');
        if (customerSourceSel) { customerSourceSel.value = g.customerSource; customerSourceSel.dispatchEvent(new Event('change', { bubbles: true })); }
        const paymentSel = [...newGroup.querySelectorAll('.rowLine select')].find(s => s.options[0]?.textContent === '支付方式');
        if (paymentSel) { paymentSel.value = g.paymentMethod; paymentSel.dispatchEvent(new Event('change', { bubbles: true })); }
        const noteInput = newGroup.querySelector('input[placeholder="註記"]');
        if (noteInput) { noteInput.value = g.note; noteInput.dispatchEvent(new Event('input', { bubbles: true })); }
        const dtInput = newGroup.querySelector('input[type="datetime-local"]');
        if (dtInput) { dtInput.value = g.datetime; dtInput.dispatchEvent(new Event('change', { bubbles: true })); }
        const deliveryInput = [...newGroup.querySelectorAll('label')].find(l => l.textContent.includes('外送資訊'))?.querySelector('input');
        if (deliveryInput) { deliveryInput.value = g.deliveryInfo; deliveryInput.dispatchEvent(new Event('input', { bubbles: true })); }
        const pointCardsInput = [...newGroup.querySelectorAll('label')].find(l => l.textContent.includes('集點卡兌換數量'))?.querySelector('input');
        if (pointCardsInput) { pointCardsInput.value = g.pointCards; pointCardsInput.dispatchEvent(new Event('input', { bubbles: true })); }
        const adjustmentInput = [...newGroup.querySelectorAll('label')].find(l => l.textContent.includes('金額調整'))?.querySelector('input');
        if (adjustmentInput) { adjustmentInput.value = g.adjustment; adjustmentInput.dispatchEvent(new Event('input', { bubbles: true })); }
        const selfContainerCheckbox = [...newGroup.querySelectorAll('label')].find(l => l.textContent.includes('自備容器'))?.querySelector('input[type=checkbox]');
        if (selfContainerCheckbox) { selfContainerCheckbox.checked = !!g.selfContainer; selfContainerCheckbox.dispatchEvent(new Event('change', { bubbles: true })); }

        // 匯入訂單
        const orderContainer = newGroup.querySelector('.orderContainer');
        const addOrderBtn = newGroup.querySelector('.rowLine .btn.add');
        while (orderContainer.querySelectorAll('.orderCard').length < g.orders.length) {
          addOrderBtn.click();
          await new Promise(r => setTimeout(r, 20));
        }
        const cards = orderContainer.querySelectorAll('.orderCard');
        cards.forEach((card, idx) => {
          const ord = g.orders[idx];
          const rowLines = card.querySelectorAll('.rowLine');
          if (rowLines[0]) {
            const sel = rowLines[0].querySelector('select');
            const num = rowLines[0].querySelector('input[type="number"]');
            if (sel) { sel.value = ord.item; sel.dispatchEvent(new Event('change', { bubbles: true })); }
            if (num) { num.value = ord.quantity; num.dispatchEvent(new Event('input', { bubbles: true })); }
          }
          if (rowLines[1]) {
            const sels = rowLines[1].querySelectorAll('select');
            if (sels[0]) { sels[0].value = ord.productA; sels[0].dispatchEvent(new Event('change', { bubbles: true })); }
            if (sels[1]) { sels[1].value = ord.productB; sels[1].dispatchEvent(new Event('change', { bubbles: true })); }
            ord.accessories.forEach((a, ai) => {
              if (sels[2 + ai]) { sels[2 + ai].value = a || ''; sels[2 + ai].dispatchEvent(new Event('change', { bubbles: true })); }
            });
          }
        });

        // 更新摘要與任務列表
        // 恢復原始顧客來源時間
        if (g.customerSourceTime) newGroup.dataset.customerSourceTime = g.customerSourceTime;
        // 重新觸發狀態選單以初始化凍結視窗
        const statusSel2 = newGroup.querySelector('.groupHeader > select');
        if (statusSel2) statusSel2.dispatchEvent(new Event('change', { bubbles: true }));
        if (typeof updateAllDailySummary === 'function') updateAllDailySummary();
        if (typeof updateTaskLists === 'function') updateTaskLists();
      }

      alert('匯入完成，請人工確認時間/狀態等細節');
    });
    input.click();
  }



  // 綁定按鈕
  const exportBtn = document.getElementById('exportTxtBtn');
  if (exportBtn) exportBtn.replaceWith(exportBtn.cloneNode(true));
  const newExportBtn = document.getElementById('exportTxtBtn');
  if (newExportBtn) newExportBtn.addEventListener('click', exportToTxt);

  const importBtn = document.getElementById('importTxtBtn');
  if (importBtn) importBtn.replaceWith(importBtn.cloneNode(true));
  const newImportBtn = document.getElementById('importTxtBtn');
  if (newImportBtn) newImportBtn.addEventListener('click', importFromTxt);
});
</script>



<script>
(function(){
  function parseCustomerSourceTime(str){
    if(!str) return null;
    const parts = str.split(':').map(n=>parseInt(n,10));
    if(parts.length<3 || parts.some(isNaN)) return null;
    const d=new Date();
    d.setHours(parts[0], parts[1], parts[2], 0);
    return d;
  }
  function updateTaskLists(){
    const now=new Date();
    const makeContainer=document.getElementById('makeTasks');
    const pickupContainer=document.getElementById('pickupTasks');
    if(!makeContainer || !pickupContainer) return;
    // preserve existing overtime-alert entries so rebuild doesn't remove their highlight
    const prevOvertime = [];
    Array.from(makeContainer.children).forEach(c=>{
      if(c.classList.contains('overtime-alert')){
        prevOvertime.push(c.textContent.trim());
      }
    });
    makeContainer.innerHTML='';
    pickupContainer.innerHTML='';
    const groups=[...document.querySelectorAll('.groupCard')];
    const makeStatuses=['未結待製','已結待製'];
    const pickupStatuses=['未結待取','已結待取'];
    function buildList(statusList, container){
      const items=groups
        .filter(g=>{
          const sel=g.querySelector('.groupHeader > select');
          return sel && statusList.includes(sel.value);
        })
        .map(g=>{
          const customerSourceTime=g.dataset.customerSourceTime||'';
          const sourceSelect=[...g.querySelectorAll('.rowLine select')].find(s=>[...s.options].some(o=>o.textContent==='顧客來源'));
          const customerSource=sourceSelect?.value||'';
          const pickupSpan=g.querySelector('.pickupText');
          const deliverySpan=g.querySelector('.deliveryText');
          let calendarText='';
          if (deliverySpan && deliverySpan.style.display !== 'none') {
            calendarText = deliverySpan.textContent;
          } else if (pickupSpan && pickupSpan.style.display !== 'none') {
            calendarText = pickupSpan.textContent;
          }
          const datetimeInput=g.querySelector('input[type="datetime-local"]');
          let calendarDate=null;
          if(datetimeInput && datetimeInput.value){
            calendarDate=new Date(datetimeInput.value);
          }
          const prod= typeof computeProductionTime === 'function' ? computeProductionTime(g) : {hours:0,minutes:0};
          const productionMs=((prod.hours*60)+prod.minutes)*60000;
          let isUrgent=false;
          if(calendarDate){
            const startBy=new Date(calendarDate.getTime() - productionMs);
            if(now >= startBy) isUrgent=true;
          }
          const customerSourceDate=parseCustomerSourceTime(customerSourceTime);
          return {
            group:g,
            status:g.querySelector('.groupHeader>select')?.value||'',
            customerSource: customerSource,
            customerSourceTime,
            customerSourceDate,
            calendarDate,
            calendarText,
            summary: window.getSummaryText ? getSummaryText(g) : '',
            isUrgent
          };
        });
      items.sort((a,b)=>{
        const groupA = a.calendarDate ? (a.isUrgent?0:1):2;
        const groupB = b.calendarDate ? (b.isUrgent?0:1):2;
        if(groupA!==groupB) return groupA - groupB;
        if(groupA===0 || groupA===1){
          if(a.calendarDate && b.calendarDate){
            if(a.calendarDate.getTime() !== b.calendarDate.getTime()){
              return a.calendarDate - b.calendarDate;
            }
          }
        } else {
          if(a.customerSourceDate && b.customerSourceDate){
            return a.customerSourceDate - b.customerSourceDate;
          } else if(a.customerSourceDate) return -1;
          else if(b.customerSourceDate) return 1;
        }
        return 0;
      });
      for(const it of items){
        const g=it.group;
        const entry=document.createElement('div');
        entry.style.padding='4px';
        entry.style.borderBottom='1px solid #ddd';
        entry.style.cursor='pointer';
        entry.style.display='flex';
        entry.style.alignItems='center';
        entry.style.gap='12px';
        const time=it.customerSourceTime || '';
        const customerSource=it.customerSource || '';
        const calendarText=it.calendarText || '';
        const summary=it.summary || '';
        const groupName = g.querySelector('.groupHeader h3')?.textContent.trim() || '';

        // info wrapper：第一行群組名稱、第二行是時間、來源、狀態合併
        const info = document.createElement('div');
        info.style.display='flex';
        info.style.flexDirection='column';
        info.style.fontSize='12px';
        info.style.lineHeight='1.1';

        const nameDiv = document.createElement('div');
        nameDiv.textContent = groupName;
        nameDiv.style.fontWeight='bold';
        info.appendChild(nameDiv);

        if (time || customerSource || calendarText) {
          const secondLine = document.createElement('div');
          let combined = '';
          if (time) combined += time;
          if (customerSource) {
            if (combined) combined += ' ';
            combined += customerSource;
          }
          if (calendarText) {
            if (combined) combined += ' ';
            combined += calendarText;
          }
          secondLine.textContent = combined;
          info.appendChild(secondLine);
        }

        const summaryDiv = document.createElement('div');
        summaryDiv.textContent = summary;
        summaryDiv.style.fontSize='2.5rem';
        summaryDiv.style.fontWeight='700';
        summaryDiv.style.whiteSpace='nowrap';

        entry.appendChild(info);
        entry.appendChild(summaryDiv);
        if (it.status && it.status.includes('未結')) {
          entry.style.color = '#8B0000';
        }
        entry.addEventListener('click', ()=>{
          g.scrollIntoView({behavior:'smooth', block:'center'});
        });
        container.appendChild(entry);
      }
    }
    buildList(makeStatuses, makeContainer);
    buildList(pickupStatuses, pickupContainer);
    // restore overdue highlights that existed before the rebuild
    if (typeof prevOvertime !== 'undefined' && prevOvertime.length) {
      Array.from(makeContainer.children).forEach(c => {
        prevOvertime.forEach(prev => {
          if (prev && (c.textContent.includes(prev) || prev.includes(c.textContent))) {
            c.classList.add('overtime-alert');
          }
        });
      });
    }
  }  window.updateTaskLists = updateTaskLists;


  function setupListeners(){
    document.querySelectorAll('.groupCard').forEach(g=>{
      const sel=g.querySelector('.groupHeader > select');
      if(sel && !sel.dataset._taskBound){
        sel.addEventListener('change', ()=>{ updateTaskLists(); });
        sel.dataset._taskBound='1';
      }
      const datetimeInput=g.querySelector('input[type="datetime-local"]');
      if(datetimeInput && !datetimeInput.dataset._taskBound){
        datetimeInput.addEventListener('change', ()=>{ updateTaskLists(); });
        datetimeInput.dataset._taskBound='1';
      }
      g.querySelectorAll('.rowLine select, .rowLine input[type="number"], .rowLine input[type="text"]').forEach(el=>{
        if(!el.dataset._taskBound){
          if(el.tagName && el.tagName.toLowerCase()==='select'){
            el.addEventListener('change', ()=>{ updateTaskLists(); });
          } else {
            el.addEventListener('input', ()=>{ updateTaskLists(); });
          }
          el.dataset._taskBound='1';
        }
      });
    });
  }

  // hook into existing summary update loop
  const origUpdateAllDailySummary = window.updateAllDailySummary;
  window.updateAllDailySummary = function(){
    if(typeof origUpdateAllDailySummary === 'function') origUpdateAllDailySummary();
    setupListeners();
    updateTaskLists();
  };
  // also call on load
  document.addEventListener('DOMContentLoaded', ()=>{
    setupListeners();
    setTimeout(updateTaskLists,500);
  });
})();
</script>


<script>
// broader delegation to ensure any change inside a groupCard triggers task list refresh
document.body.addEventListener('input', e => {
  if (e.target.closest && e.target.closest('.groupCard')) updateTaskLists();
}, true);
document.body.addEventListener('change', e => {
  if (e.target.closest && e.target.closest('.groupCard')) updateTaskLists();
}, true);
</script>


<script>
// 強制指定群組容器，修正 sticky 失效問題
window.findGroupContainer = function() {
  const container = document.getElementById('groupsContainer');
  if (container) return container;
  const existing = document.querySelector('.groupCard');
  if (existing && existing.parentElement) return existing.parentElement;
  const sticky = document.querySelector('.stickyBar');
  if (sticky) {
    let next = sticky.nextElementSibling;
    while (next) {
      if (next.tagName && next.tagName.toLowerCase() === 'div') return next;
      next = next.nextElementSibling;
    }
  }
  return document.body;
};
</script>
</body>
</html>
